<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Stochastic Frontier Analysis using Julia</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-134239283-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-134239283-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Stochastic Frontier Analysis using Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Stochastic Frontier Analysis using Julia</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home of SFrontiers.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="overview.html">Estimation Overview</a></li><li><a class="tocitem" href="ex_detail.html">A Detailed Example</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Other Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ex_cross.html">cross-sectional models</a></li><li><a class="tocitem" href="ex_panel.html">panel models</a></li></ul></li><li class="is-active"><a class="tocitem" href="api.html">API Reference</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li><li><a class="tocitem" href="LICENSE.html">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href="api.html">API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfmodel_boot_marginal-Tuple{}" href="#SFrontiers.sfmodel_boot_marginal-Tuple{}"><code>SFrontiers.sfmodel_boot_marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sfmodel_boot_marginal(&lt;keyword arguments&gt;)</code></pre><p>Bootstrap standard errors of the mean marginal effects of inefficiency determinants. Return a vector of standard errors of <span>$K x 1$</span> where <span>$K$</span> is the number of exogenous inefficiency determinants. Optionally returns bootstrapped data (<span>$R x K$</span> with <code>getBootData=true</code>). </p><p><strong>Arguments</strong></p><ul><li>result=&lt;returned result&gt;: The returned result from <code>sfmodel_fit()</code>.</li><li>data=&lt;dataset&gt;: The DataFrame dataset containing the model&#39;s data. Same as the one used in <code>sfmodel_fit()</code>. If the data was supplied by matrix (instead of DataFrame; i.e., the Method 2 of <code>sfmodel_spec()</code>), this option should be skipped.</li><li>R::Integer=&lt;number&gt;: The number of bootstrapped samples. The default is 500.</li><li>seed::Integer=&lt;number&gt;: A postive integer used to seed the random number generator (rng) for resampling, which ensures reproducibility. This rng is not global and is only effective in this function. If not specified, the global random number generator is used, and the bootstrap result may change (slightly) between different runs.</li><li>iter::Integer=&lt;number&gt;: The maximum number of iterations for each bootstrapped sample. If the number is larger than 0, it overwrites the <code>main_maxIT</code>  specified in <code>sfmodel_opt()</code> which is the default.</li><li>getBootData::Bool=false: Whether to return the bootstrapped data which is <span>$R x K$</span> where K is the number of exogenous determinants of inefficiency. Default return only the bootstrapped standard errors (which is <span>$K x 1$</span>).</li><li>every::Integer=10: Print bootstrapping progress for every <code>every</code> samples.</li></ul><p><strong>Remarks</strong></p><ul><li>Bootstrap samples are with replacement. For panel data, it samples cross-sectional units with replacement.</li><li>In the MLE estimation, estimated coefficients  from the main result is used as initial values. There is no <code>warmstart</code>. The <code>main_solver</code>, <code>main_maxIT</code>, and <code>tolerance</code> specified in <code>sfmodel_opt()</code> are used as default, but the value of <code>main_maxIT</code> may be replaced by the <code>iter</code> option.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; b_err = sfmodel_boot_marginal(result=res, data=df, 
                 R=250, seed=123)  

┌────────┬──────────────────────┬──────────────────────┐
│        │ mean of the marginal │      std.err. of the │
│        │       effect on E(u) │ mean marginal effect │
├────────┼──────────────────────┼──────────────────────┤
│    age │            -0.002645 │               0.0022 │
│ school │           -0.0119745 │               0.0176 │
│     yr │           -0.0265006 │               0.0123 │
└────────┴──────────────────────┴──────────────────────┘

3×1 adjoint(::Matrix{Float64}) with eltype Float64:
 0.0022466588714701637
 0.01761274009269851
 0.012314936361028156

julia&gt; b_err, b_data = sfmodel_boot_marginal(result=res, 
       data=df, R=250, seed=123, getBootData=true); </code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfmodel_fit-Tuple{}" href="#SFrontiers.sfmodel_fit-Tuple{}"><code>SFrontiers.sfmodel_fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sfmodel_fit(&lt;keyword arguments&gt;)</code></pre><p>Maximum likelihood estimation of the stochastic frontier model specified  in <code>sfmodel_spec(...)</code>. Estimate the model parameters, calculate Jondrow et al.  (1982) inefficiency index and Battese and Coelli (1988) efficiency index,  compute marginal effects of inefficiency determinants (if any). Return a dictionary with results.</p><p><strong>Arguments</strong></p><ul><li><code>useData(::DataFrame)</code>: The DataFrame used with the Method 1 of <code>sfmodel_spec(...)</code>. If use Method 2 of <code>sfmodel_spec(...)</code> (viz., data is supplied by individual matrices), do not need this keyword argument.</li></ul><p><strong>Remarks</strong></p><ul><li>Use <code>Optim.jl</code> to carry out the estimation.</li><li>Users do not need to provide gradient or Hessian functions even if  gradient-based optimization algorithms are used. The package uses automatic differentiation (https://en.wikipedia.org/wiki/Automatic_differentiation) to  compute the derivatives. AD is not numerical finite differentiation. AD is fast and as accurate as the symbolic differentiation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_fit(useData(df))    # Method 1
sfmodel_fit()               # Method 2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfmodel_init-Tuple" href="#SFrontiers.sfmodel_init-Tuple"><code>SFrontiers.sfmodel_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sfmodel_init(&lt;keyword arguments&gt;)</code></pre><p>Provide initial values for the stochastic frontier model estimation. The values could be a vector or scalars. It creates a global dictionary <code>_dicINI</code>. Optional.</p><p><strong>Arguments</strong></p><ul><li><code>all_init(::Union{Vector, Real})</code>: initial values of all the parameters in the model</li><li><code>frontier(::Union{Vector, Real})</code>: initial values of parameters in the <code>frontier()</code> function</li><li><code>μ(::Union{Vector, Real})</code> or <code>mu(::Union{Vector, Real})</code>: initial values of parameters in the <code>μ</code> function</li><li><code>hscale(::Union{Vector, Real})</code>: initial values of parameters in the <code>hscale()</code> function</li><li><code>gamma(::Union{Vector, Real})</code>: initial values of parameters in the <code>gamma()</code> function</li><li><code>σᵤ²(::Union{Vector, Real})</code> or <code>sigma_u_2(::Union{Vector, Real})</code>: initial values of parameters in the  <code>σᵤ²</code> function</li><li><code>σᵥ²(::Union{Vector, Real})</code> or <code>sigma_v_2(::Union{Vector, Real})</code>: initial values of parameters in the  <code>σᵥ²</code> function    </li><li><code>σₐ²(::Union{Vector, Real})</code> or <code>sigma_a_2(::Union{Vector, Real})</code>: initial values of parameters in the <code>σₐ²</code> function</li><li>message::Bool: Whether printing (=true) or not (=false, the default) the confirmation message &quot;A dictionary from sfmodel<em>init() is generated.&quot; on the screen after `sfmodel</em>init()` is successfully executed.</li></ul><p><strong>Remarks</strong></p><ul><li>Equations do not have to follow specific orders.</li><li><code>sfmodel_init(...)</code> is optional but is highly recommended. If it is not specified or is specified as an empty set, default values are used.</li><li>It is not necessary to specify a complete set of equations. A partial list  or even empty lists are acceptable. Default values will be substituted for the missing equations.</li><li>The generated <code>_dicINI</code> is inheritable in the sense that an exiting <code>_dicINI</code> (from the previous run of the same or a different model, for example) will be used if the current model does not have its own <code>sfmodel_init(...)</code>. This design has advantages in a simulations study where <code>sfmodel_init(...)</code> needs to be specified only once.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">b_ini = ones(2)*0.2
sfmodel_init( # frontier(bb),             # may skip and use default
             μ(b_ini),                    # may use a vector
             σᵤ²(-0.1, -0.1),  
             σᵥ²(-0.1) )                   

sfmodel_init(all_init(0.1, 0.2, 0.5, 0.0, -0.1, -0.1, -0.1),
             message = false)             </code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfmodel_opt-Tuple" href="#SFrontiers.sfmodel_opt-Tuple"><code>SFrontiers.sfmodel_opt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sfmodel_opt(&lt;keyword arguments&gt;)</code></pre><p>Provide options to the optimization algorithms for the maiximum likelihood estimation. It creates a global dictionary <code>_dicOPT</code>. Optional. The <code>Optim</code> package is used for the optimization, and a subset of <code>Optim</code>&#39;s keywords are directly accessible from this API. </p><p><strong>Arguments</strong></p><ul><li><code>warmstart_solver(algorithm)</code>: The algorithm used in the first-stage (&quot;warmstart&quot;) optimization process, which serves the purpose of improving upon the initial values for the second-stage (&quot;main&quot;) estimation. The default is <code>NelderMead()</code>. Others include <code>SimulatedAnnealing()</code>, <code>SAMIN()</code>, <code>ParticleSwarm()</code>, <code>ConjugateGradient()</code>, <code>GradientDescent()</code>, <code>BFGS()</code>, <code>LBFGS()</code>, <code>Newton()</code>, <code>NewtonTrustRegion()</code>, and <code>IPNewton()</code>. See http://julianlsolvers.github.io/Optim.jl/stable/ for details. Non-gradient based algorithms are recommended for the warmstart solver. </li><li><code>warmstart_maxIT(::Int64)</code>: The iteration limit for the warmstart. Default is 100.</li><li><code>main_solver(algorithm)</code>: The algorithm used in the main opimization process. The default is <code>Newton()</code>. Others include <code>SimulatedAnnealing()</code>, <code>SAMIN()</code>, <code>ParticleSwarm()</code>, <code>ConjugateGradient()</code>, <code>GradientDescent()</code>, <code>BFGS()</code>, <code>LBFGS()</code>, <code>NewtonTrustRegion()</code>, and <code>IPNewton()</code>. See http://julianlsolvers.github.io/Optim.jl/stable/ for details.</li><li><code>main_maxIT(::Int64)</code>: The iteration limit for the main estimation. Default is 2000.</li><li><code>tolerance(::Float64)</code>: The convergence criterion (&quot;tolerance&quot;) based on the absolute value of gradients. Default is 1.0e-8. For non-gradient algorithms, it controls the main convergence tolerance, which is solver specific.  See <code>Optim</code>&#39;s <code>g_tol</code> option for more information.</li><li><code>verbose(::Bool)</code>: Print on screen (<code>true</code>, the default) the information of the model and the optimization results.</li><li><code>banner(::Bool)</code>: Print on screen (<code>true</code>, the default) a banner to serve as a visual indicator of the start of the estimation.</li><li><code>ineff_index(::Bool)</code>: Whether to compute the Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1988) efficiency index. The defauis <code>true</code>.</li><li><code>marginal(::Bool)</code>: Whether to compute the marginal effects of the exogenous determinants of inefficiency (if any).</li><li><code>table_format()</code>: The format to print the coefficient tables on the screen: <code>text</code> (default), <code>html</code>, or <code>latex</code>. A wrapper of <code>PrettyTables.jl</code>&#39;s <code>backend</code> option.</li><li>message::Bool: Whether printing (=true) or not (=false, the default) the confirmation message &quot;A dictionary from sfmodel<em>opt() is generated.&quot; on the screen after `sfmodel</em>opt()` is successfully executed.</li></ul><p><strong>Remarks</strong></p><ul><li><code>sfmodel_opt(...)</code> is optional. It can be omitted entirely, or specifying only a partial list of the keywords.</li><li>If any of the keywords are missing, default values are used.</li><li>If warmstart is not needed, you need to give empty keyword values to warmstart related keys. E.g., either <code>warmstart_solver()</code> or <code>warmstart_maxIT()</code>, or both. Omitting the keyword entirely (i.e., not writing down <code>warmstart_solver</code> or <code>warmstart_maxIT</code>) will not skip the warmstart, but will reinstate the default. </li><li>Users do not need to provide gradient or Hessian functions even if  gradient-based optimization algorithms are used. The package uses automatic differentiation (https://en.wikipedia.org/wiki/Automatic_differentiation) to  compute the derivatives. It is not numerical finite differentiation. It is fast and as accurate as the symbolic differentiation.</li><li>The <code>_dicOPT</code> is inheritable in the sense that an exiting <code>_dicOPT</code> (from the previous run of the same or a different model, for example) will be used if the current model does not have its own <code>sfmodel_opt(...)</code>. This design has advantages in simulation studies where <code>sfmodel_opt(...)</code> needs to be specified only once.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt(warmstart_solver(NelderMead()),   
            warmstart_maxIT(200),
            main_solver(Newton()), 
            main_maxIT(2000), 
            tolerance(1e-8),
            message = false)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfmodel_spec-Tuple" href="#SFrontiers.sfmodel_spec-Tuple"><code>SFrontiers.sfmodel_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sfmodel_spec(&lt;keyword arguments&gt;)</p><p>Provide specifications of the stochastic frontier model, including the type of model and names of variables or matrix used in estimating the model. Two ways to specify: Method 1: Use DataFrame as input, and Method 2: use matrix as input.</p><p><strong>Method 1 (DataFrame input)</strong></p><p>Variables come from a DataFrame, and column names of the Dataframe are used in the variable input. With this method, equations are identified by macros but not functions (e.g., <code>@depvar()</code> but not <code>depvar()</code>).</p><p><strong>Arguments of Method 1</strong></p><ul><li><code>sfdist(::Vararg)</code>: the distribution assumption of the one-sided stochastic variable (aka inefficiency term) of the model; possible choices include <code>truncated</code> (or <code>trun</code>, <code>t</code>), <code>half</code> (or <code>h</code>), <code>exponential</code> (or <code>expo</code>, <code>e</code>), and <code>trun_scale</code> (or <code>trun_scaling</code>, <code>ts</code>).</li><li><code>sftype(::Vararg)</code>: whether the model is a <code>production</code> (or <code>prod</code>) frontier or a <code>cost</code> frontier.</li><li><code>sfpanel(::Vararg)</code>: the type of panel model. Choices include <code>FE_WH2010</code> (true fixed effect model of Wang and Ho 2010 JE), <code>TFE_CSW2014</code> (true fixed model of Chen, Schmidt, and Wang 2014 JE),  <code>TRE</code> (true random effect model of Greene 2004), <code>TimeDecay</code> (time decay model of Battese and Coelli 1992).</li><li><code>@depvar(::Vararg)</code>: the dependent variable from a DataFrame.</li><li><code>@frontier(::Vararg)</code>: a list of variables, separated by commas, in the frontier function.</li><li><code>@μ(::Vararg)</code> or <code>@mu(::Vararg)</code>: a list of variable, separated by comma, in the linear function of μ. (<code>sftype(trun)</code> only).</li><li><code>@σᵥ²(::Vararg)</code> or <code>@sigma_v_2(::Vararg)</code>: a list of variable, separated by comma, in the σᵥ² equation.</li><li><code>@σᵤ²(::Vararg)</code> or <code>@sigma_u_2(::Vararg)</code>: a list of variable, separated by comma, in the σᵤ² equation.</li><li><code>@σₐ²(::Vararg)</code> or <code>@sigma_a_2(::Vararg)</code>: a list of variable, separated by comma, in the σₐ² equation. <code>sfpanel(TRE)</code> only.</li><li><code>@gamma(::Vararg)</code>: a list of variables, separated by commas, in the gamma equation. <code>sfpanel(TimeDecay)</code> only.</li><li><code>@timevar(::Vararg)</code>: the variable containing the time period information. Panel data model only.</li><li><code>@idvar(::Vararg)</code>: the variable identifying each individual. Panel data model only.</li><li>message::Bool: Whether printing (=true) or not (=false, the default) the confirmation message &quot;A dictionary from sfmodel<em>spec() is generated.&quot; on the screen after `sfmodel</em>spec()` is successfully executed.  </li></ul><p><strong>Method 2 (matrix/vector input)</strong></p><p>Data of the variables are provided by individual matrices or vectors, and names of the mat/vec are used in the equations. With this method, equations are identified by functions but not macros (e.g., <code>depvar()</code> but not <code>@depvar()</code>). Note that if, for instance, the name of <code>depvar</code> or <code>σᵤ²</code> has been used elsewhere in the program, using these names to read in mat/vec will cause name conflict (<code>MethodError: objects of type ... are not callable</code>). The workaround is to fully qualify the function names, e.g., <code>SFrontiers.depvar</code>, <code>SFrontiers.σᵤ²</code>, etc. Or, use the alias (if available), e.g., <code>sigma_u_2</code> instead of <code>σᵤ²</code>.</p><p><strong>Arguments of Method 2</strong></p><ul><li><code>sfdist(::Vararg)</code>: the distribution assumption on the inefficiency term; possible choices include <code>truncated</code> (or <code>trun</code>, <code>t</code>), <code>half</code> (or <code>h</code>), <code>exponential</code> (or <code>expo</code>, <code>e</code>), and <code>trun_scale</code> (or <code>trun_scaling</code>, <code>ts</code>).</li><li><code>sftype(::Vararg)</code>: whether the model is a <code>production</code> (or <code>prod</code>) frontier or a <code>cost</code> frontier.</li><li><code>sfpanel(::Vararg)</code>: the type of panel model. Choices include <code>FE_WH2010</code> (true fixed effect model of Wang and Ho 2010 JE), <code>TFE_CSW2014</code> (true fixed model of Chen, Schmidt, and Wang 2014 JE),  <code>TRE</code> (true random effect model of Greene 2004), <code>TimeDecay</code> (time decay model of Battese and Coelli 1992).</li><li><code>depvar(::Matrix)</code>: Matrix or vector of the dependent variable.</li><li><code>frontier(::Matrix)</code>: matrix or vector for frontier function.</li><li><code>μ(::Matrix)</code> or <code>mu(::Matrix)</code>: matrix or vector for the (linear) μ equation (<code>trun</code> type only).</li><li><code>σᵤ²(::Matrix)</code> or <code>sigma_u_2(::Matrix)</code>: matrix or vector for the σᵤ² equation.</li><li><code>σₐ²(::Matrix)</code> or <code>sigma_a_2(::Matrix)</code>: matrix or vector for the σₐ² equation.</li><li>message::Bool: Whether printing (=true) or not (=false, the default) the confirmation message &quot;A dictionary from sfmodel<em>spec() is generated.&quot; on the screen after `sfmodel</em>spec()` is successfully executed.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_spec(sftype(prod), sfdist(trun),
             @depvar(output), 
             @frontier(land, , labor, bull, year, _cons), 
             @μ(age, school, year, _cons),
             @σᵤ²(age, school, year, _cons),
             @σᵥ²(_cons));

sfmodel_spec(sfpanel(TRE), sftype(prod), sfdist(half),
             @timevar(yr), @idvar(id),
             @depvar(y), 
             @frontier(x1, x2, _cons), 
             @σₐ²(_cons),
             @σᵤ²(_cons),
             @σᵥ²(_cons),
             message = false);</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.all_init-Tuple{Vector{T} where T}" href="#SFrontiers.all_init-Tuple{Vector{T} where T}"><code>SFrontiers.all_init</code></a> — <span class="docstring-category">Method</span></header><section><div><p>all_init(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for all the parameters in the model.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init( all_init(0.1, 0.2, 0.5, -0.1, -0.1, -0.2), ...)

b0 = ones(6)*0.1
sfmodel_init( all_init(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.banner" href="#SFrontiers.banner"><code>SFrontiers.banner</code></a> — <span class="docstring-category">Function</span></header><section><div><p>banner(arg::Bool)</p><p>An argument in <code>sfmodel_opt()</code>. Specify whether to print on screen (<code>true</code>, the default) a banner to serve as a visual indicator of the start of the  estimation.</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt( banner(false), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.depvar-Tuple" href="#SFrontiers.depvar-Tuple"><code>SFrontiers.depvar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>depvar(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the maxrix name where the matrix is used as the data of the dependent variable.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ymat
100×1 Matrix{Float64}:
  0.0005852467656204083
 -0.9128698116696892
 -1.1087862468093093
 -1.0714018769972091
 -0.606943663382492
  0.37648407866805467
 -0.1281971631844683
  ⋮
  0.8541895741866585
  1.5109216952026845
 -0.3519833126683764
 -1.0378799750720447
 -0.9990384371507885
  0.18858962788775305

sfmodel_spec(depvar(ymat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.frontier-Tuple" href="#SFrontiers.frontier-Tuple"><code>SFrontiers.frontier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>frontier(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the name of the maxrix used as the data of the <code>frontier</code> function.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; xmat
100×3 Matrix{Float64}:
 -0.682942    0.440045   1.0
 -0.680902   -1.68124    1.0
  1.29108    -1.5516     1.0
  0.683652   -0.0319451  1.0
 -0.973079    1.11636    1.0
 -0.343229    0.314457   1.0
  0.107583    0.688177   1.0
  ⋮
  0.0943377  -0.781928   1.0
 -0.599142   -1.01591    1.0
 -0.56726    -1.03394    1.0
  1.33522     0.135763   1.0
  1.13235     0.0177493  1.0
 -0.310638   -0.314166   1.0

sfmodel_spec(frontier(xmat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.frontier-Tuple{Vector{T} where T}" href="#SFrontiers.frontier-Tuple{Vector{T} where T}"><code>SFrontiers.frontier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>frontier(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for coefficients in the <code>frontier</code> function.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init(frontier(0.1, 0.2, 0.5), ...)
b0 = ones(3)*0.1
sfmodel_init( frontier(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.gamma-Tuple" href="#SFrontiers.gamma-Tuple"><code>SFrontiers.gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><p>gamma(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the name of the maxrix used as the data of the <code>gamma</code> function.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gmat
100×2 Matrix{Float64}:
 -0.943133   1.0
 -0.897392   1.0
  0.585447   1.0
 -0.46106    1.0
 -0.54563    1.0
 -0.619428   1.0
  0.0575559  1.0
  ⋮
  0.0844192  1.0
 -1.3339     1.0
  1.29332    1.0
  0.691466   1.0
  0.422962   1.0
  0.374425   1.0

sfmodel_spec(gamma(gmat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.gamma-Tuple{Vector{T} where T}" href="#SFrontiers.gamma-Tuple{Vector{T} where T}"><code>SFrontiers.gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><p>gamma(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for coefficients in the <code>gamma</code> function.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init( gamma(0.1, 0.2, 0.5), ...)

b0 = ones(3)*0.1
sfmodel_init( gamma(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.hscale-Tuple" href="#SFrontiers.hscale-Tuple"><code>SFrontiers.hscale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>hscale(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the name of the maxrix used as the data of the <code>hscale</code> function.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hmat
100×2 Matrix{Float64}:
 -0.943133   1.0
 -0.897392   1.0
  0.585447   1.0
 -0.46106    1.0
 -0.54563    1.0
 -0.619428   1.0
  0.0575559  1.0
  ⋮
  0.0844192  1.0
 -1.3339     1.0
  1.29332    1.0
  0.691466   1.0
  0.422962   1.0
  0.374425   1.0

sfmodel_spec(hscale(hmat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.hscale-Tuple{Vector{T} where T}" href="#SFrontiers.hscale-Tuple{Vector{T} where T}"><code>SFrontiers.hscale</code></a> — <span class="docstring-category">Method</span></header><section><div><p>hscale(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for coefficients in the <code>hscale</code> function.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init( hscale(0.1, 0.2, 0.5), ...)

b0 = ones(3)*0.1
sfmodel_init( hscale(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.idvar-Tuple" href="#SFrontiers.idvar-Tuple"><code>SFrontiers.idvar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>idvar(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code> for panel data models. Specify the name of the matrix containing the individual&#39;s id information of the panel data. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; idmat
100-element Vector{Int64}:
  1
  1
  1
  1
  2
  2
  2
  ⋮
 24
 24
 25
 25
 25
 25

sfmodel_spec( idvar(idmat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.ineff_index" href="#SFrontiers.ineff_index"><code>SFrontiers.ineff_index</code></a> — <span class="docstring-category">Function</span></header><section><div><p>ineff_index(arg::Bool)</p><p>An argument in <code>sfmodel_opt()</code>. Specify whether (<code>true</code>, the default) to compute the Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1988) efficiency index.</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt( ineff_index(false), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.main_maxIT" href="#SFrontiers.main_maxIT"><code>SFrontiers.main_maxIT</code></a> — <span class="docstring-category">Function</span></header><section><div><p>main_maxIT(arg)</p><p>An argument in <code>sfmodel_opt()</code>. Specify the iteration limit for the main solver. Default  is 2000.</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><p><code>julia-repl  sfmodel_opt( main_maxIT(2500), ...)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.main_solver" href="#SFrontiers.main_solver"><code>SFrontiers.main_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>main_solver(arg)</p><p>An argument in <code>sfmodel_opt()</code>. Specify the algorithm used in the 2nd-stage (&quot;main&quot;)   optimization process.</p><p>The default is <code>Newton()</code>. Others include <code>SimulatedAnnealing()</code>, <code>SAMIN()</code>, <code>ParticleSwarm()</code>,   <code>ConjugateGradient()</code>, <code>GradientDescent()</code>, <code>BFGS()</code>, <code>LBFGS()</code>,   <code>NewtonTrustRegion()</code>, and <code>IPNewton()</code>. See   http://julianlsolvers.github.io/Optim.jl/stable/ for details.</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt( main_solver(Newton()), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.marginal" href="#SFrontiers.marginal"><code>SFrontiers.marginal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>marginal(arg::Bool)</p><p>An argument in <code>sfmodel_opt()</code>. Specify whether (<code>true</code>, the default) to  compute the marginal effects of the exogenous determinants of inefficiency (if any).</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><p><code>julia-repl  sfmodel_opt( marginal(false), ...)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.mu-Tuple" href="#SFrontiers.mu-Tuple"><code>SFrontiers.mu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mu(arg::Vararg)</p><p>alias of μ. See help on μ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.mu-Tuple{Vector{T} where T}" href="#SFrontiers.mu-Tuple{Vector{T} where T}"><code>SFrontiers.mu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mu(arg::Vector)</p><p>alias of μ. See help on μ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfdist-Tuple" href="#SFrontiers.sfdist-Tuple"><code>SFrontiers.sfdist</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sfdist(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the distribution assumption of the one-sided stochastic variable (aka inefficiency term) of the model. Possible choices include <code>truncated</code> (or <code>trun</code>, <code>t</code>), <code>half</code> (or <code>h</code>), <code>exponential</code> (or <code>expo</code>, <code>e</code>), and <code>trun_scale</code> (or <code>trun_scaling</code>, <code>ts</code>).</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_spec(sfdist(t), ...)
sfmodel_spec(sfdist(h), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sftype-Tuple" href="#SFrontiers.sftype-Tuple"><code>SFrontiers.sftype</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sftype(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify whether the model is a <code>production</code> (or <code>prod</code>) frontier or a <code>cost</code> frontier.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sftype(production)
sftype(cost)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sigma_a_2-Tuple" href="#SFrontiers.sigma_a_2-Tuple"><code>SFrontiers.sigma_a_2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sigma<em>a</em>2(arg::Vararg)</p><p>alias of σₐ². See help on σₐ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sigma_a_2-Tuple{Vector{T} where T}" href="#SFrontiers.sigma_a_2-Tuple{Vector{T} where T}"><code>SFrontiers.sigma_a_2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sigma<em>a</em>2(arg::Vector)</p><p>alias of σₐ². See help on σₐ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sigma_u_2-Tuple" href="#SFrontiers.sigma_u_2-Tuple"><code>SFrontiers.sigma_u_2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sigma<em>u</em>2(arg::Vararg)</p><p>alias of σᵤ². See help on σᵤ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sigma_u_2-Tuple{Vector{T} where T}" href="#SFrontiers.sigma_u_2-Tuple{Vector{T} where T}"><code>SFrontiers.sigma_u_2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sigma<em>u</em>2(arg::Vector)</p><p>alias of σᵤ². See help on σᵤ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sigma_v_2-Tuple" href="#SFrontiers.sigma_v_2-Tuple"><code>SFrontiers.sigma_v_2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sigma<em>v</em>2(arg::Vararg)</p><p>alias of σᵥ². See help on σᵥ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sigma_v_2-Tuple{Vector{T} where T}" href="#SFrontiers.sigma_v_2-Tuple{Vector{T} where T}"><code>SFrontiers.sigma_v_2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>sigma<em>v</em>2(arg::Vector)</p><p>alias of σᵥ². See help on σᵥ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.table_format" href="#SFrontiers.table_format"><code>SFrontiers.table_format</code></a> — <span class="docstring-category">Function</span></header><section><div><p>table_format(arg)</p><p>An argument in <code>sfmodel_opt()</code>. Specify the format to print the coefficient  tables on the screen: <code>text</code> (default), <code>html</code>, or <code>latex</code>. A wrapper of <code>PrettyTables.jl</code>&#39;s  <code>backend</code> option.</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><p><code>julia-repl  sfmodel_opt( table_format(html), ...)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.timevar-Tuple" href="#SFrontiers.timevar-Tuple"><code>SFrontiers.timevar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>timevar(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code> for panel data models. Specify the name of the matrix containing the time information of the panel data. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; timemat
100-element Vector{Int64}:
 2019
 2020
 2021
 2022
 2019
 2020
 2021
    ⋮
 2021
 2022
 2019
 2020
 2021
 2022

sfmodel_spec( timvar(timemat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.tolerance" href="#SFrontiers.tolerance"><code>SFrontiers.tolerance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>tolerance(arg::Float64)</p><p>An argument in <code>sfmodel_opt()</code>. Specify the convergence criterion (&quot;tolerance&quot;) based on the absolute value of gradients. Default is 1.0e-8. For non-gradient algorithms, it controls the main convergence tolerance, which is solver specific.  See <code>Optim</code>&#39;s <code>g_tol</code> option for more information.</p><p>Also see the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt( tolerance(1.0e-6), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.useData-Tuple{DataFrames.DataFrame}" href="#SFrontiers.useData-Tuple{DataFrames.DataFrame}"><code>SFrontiers.useData</code></a> — <span class="docstring-category">Method</span></header><section><div><p>useData(D::DataFrame)</p><p>An argument in <code>sfmodel_fit()</code>. Specify the name of the DataFrame that   contains the estimation data.</p><p>See the help on <code>sfmodel_fit()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">  julia&gt; mydf
  100×4 DataFrame
  │ Row │ year  │ firm  │ yvar  │ xvar1     │
  │     │ Int64 │ Int64 │ Int64 │ Float64   │
  ├─────┼───────┼───────┼───────┼───────────┤
  │ 1   │ 2019  │ 1     │ 1     │ 0.77645   │
  │ 2   │ 2020  │ 1     │ 2     │ 0.0782388 │
  │ 3   │ 2021  │ 1     │ 3     │ 0.222884  │
  │ 4   │ 2022  │ 1     │ 4     │ 0.762864  │
  ⋮
  │ 96  │ 2022  │ 24    │ 96    │ 0.590184  │
  │ 97  │ 2019  │ 25    │ 97    │ 0.364425  │
  │ 98  │ 2020  │ 25    │ 98    │ 0.639463  │
  │ 99  │ 2021  │ 25    │ 99    │ 0.500526  │
  │ 100 │ 2022  │ 25    │ 100   │ 0.239137  │

  sfmodel_fit(useData(mydf), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.verbose" href="#SFrontiers.verbose"><code>SFrontiers.verbose</code></a> — <span class="docstring-category">Function</span></header><section><div><p>verbose(arg::Bool)</p><p>An argument in <code>sfmodel_opt()</code>. Specify whether to print on screen (<code>true</code>, the default) the information of the model and the optimization results.</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt( verbose(false), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.warmstart_maxIT" href="#SFrontiers.warmstart_maxIT"><code>SFrontiers.warmstart_maxIT</code></a> — <span class="docstring-category">Function</span></header><section><div><p>warmstart_maxIT(arg)</p><p>An argument in <code>sfmodel_opt()</code>. Specify the iteration limit for the warmstart. Default is 100.</p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt( warmstart_maxIT(400), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.warmstart_solver" href="#SFrontiers.warmstart_solver"><code>SFrontiers.warmstart_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>warmstart_solver(arg)</p><p>An argument in <code>sfmodel_opt()</code>. Specify the algorithm used in the first-stage (&quot;warmstart&quot;)   optimization process.</p><p>The default is <code>NelderMead()</code>. Others include <code>SimulatedAnnealing()</code>, <code>SAMIN()</code>, <code>ParticleSwarm()</code>,   <code>ConjugateGradient()</code>, <code>GradientDescent()</code>, <code>BFGS()</code>, <code>LBFGS()</code>,   <code>Newton()</code>, <code>NewtonTrustRegion()</code>, and <code>IPNewton()</code>. See   http://julianlsolvers.github.io/Optim.jl/stable/ for details.   Non-gradient based algorithms are recommended for the warmstart solver. </p><p>See the help on <code>sfmodel_opt()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_opt( warmstart_solver(NelderMead()), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.μ-Tuple" href="#SFrontiers.μ-Tuple"><code>SFrontiers.μ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>μ(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the name of the maxrix used as the data of the <code>μ</code> function.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mumat
100×2 Matrix{Float64}:
 -0.943133   1.0
 -0.897392   1.0
  0.585447   1.0
 -0.46106    1.0
 -0.54563    1.0
 -0.619428   1.0
  0.0575559  1.0
  ⋮
  0.0844192  1.0
 -1.3339     1.0
  1.29332    1.0
  0.691466   1.0
  0.422962   1.0
  0.374425   1.0

sfmodel_spec(μ(mumat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.μ-Tuple{Vector{T} where T}" href="#SFrontiers.μ-Tuple{Vector{T} where T}"><code>SFrontiers.μ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>μ(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for coefficients in the <code>μ</code> function.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init( μ(0.1, 0.2, 0.5), ...)

b0 = ones(3)*0.1
sfmodel_init( μ(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.σᵤ²-Tuple" href="#SFrontiers.σᵤ²-Tuple"><code>SFrontiers.σᵤ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σᵤ²(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the name of the maxrix used as the data of the <code>σᵤ²</code> function.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zmat
100×2 Matrix{Float64}:
 -0.943133   1.0
 -0.897392   1.0
  0.585447   1.0
 -0.46106    1.0
 -0.54563    1.0
 -0.619428   1.0
  0.0575559  1.0
  ⋮
  0.0844192  1.0
 -1.3339     1.0
  1.29332    1.0
  0.691466   1.0
  0.422962   1.0
  0.374425   1.0

sfmodel_spec(σᵤ²(zmat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.σᵤ²-Tuple{Vector{T} where T}" href="#SFrontiers.σᵤ²-Tuple{Vector{T} where T}"><code>SFrontiers.σᵤ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σᵤ²(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for coefficients in the <code>σᵤ²</code> function.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init( σᵤ²(0.1, 0.2, 0.5), ...)

b0 = ones(3)*0.1
sfmodel_init( σᵤ²(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.σᵥ²-Tuple" href="#SFrontiers.σᵥ²-Tuple"><code>SFrontiers.σᵥ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σᵥ²(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the name of the maxrix used as the data of the <code>σᵥ²</code> function.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sigv2mat
100×2 Matrix{Float64}:
 -0.943133   1.0
 -0.897392   1.0
  0.585447   1.0
 -0.46106    1.0
 -0.54563    1.0
 -0.619428   1.0
  0.0575559  1.0
  ⋮
  0.0844192  1.0
 -1.3339     1.0
  1.29332    1.0
  0.691466   1.0
  0.422962   1.0
  0.374425   1.0

sfmodel_spec(σᵥ²(sigv2mat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.σᵥ²-Tuple{Vector{T} where T}" href="#SFrontiers.σᵥ²-Tuple{Vector{T} where T}"><code>SFrontiers.σᵥ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σᵥ²(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for coefficients in the <code>σᵥ²</code> function.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init( σᵥ²(0.1, 0.2, 0.5), ...)

b0 = ones(3)*0.1
sfmodel_init( σᵥ²(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.σₐ²-Tuple" href="#SFrontiers.σₐ²-Tuple"><code>SFrontiers.σₐ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σₐ²(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the name of the maxrix used as the data of the <code>σₐ²</code> function.</p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; amat
100×2 Matrix{Float64}:
 -0.943133   1.0
 -0.897392   1.0
  0.585447   1.0
 -0.46106    1.0
 -0.54563    1.0
 -0.619428   1.0
  0.0575559  1.0
  ⋮
  0.0844192  1.0
 -1.3339     1.0
  1.29332    1.0
  0.691466   1.0
  0.422962   1.0
  0.374425   1.0

sfmodel_spec(σₐ²(amat), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.σₐ²-Tuple{Vector{T} where T}" href="#SFrontiers.σₐ²-Tuple{Vector{T} where T}"><code>SFrontiers.σₐ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>σₐ²(arg::Vector)</p><p>An argument in <code>sfmodel_init()</code>. Specify the initial values for coefficients in the <code>σₐ²</code> function.</p><p>See the help on <code>sfmodel_init()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_init( σₐ²(0.1, 0.2, 0.5), ...)

b0 = ones(3)*0.1
sfmodel_init( σₐ²(b0), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@depvar-Tuple" href="#SFrontiers.@depvar-Tuple"><code>SFrontiers.@depvar</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@depvar(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the dependent variable using a column name from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec(@depvar(yvar), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@eq-Tuple{Any}" href="#SFrontiers.@eq-Tuple{Any}"><code>SFrontiers.@eq</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@eq(arg)</p><p>An argument in <code>sfmodel_predict()</code>. Specify the name of the function to be predicted. </p><p>See the help on <code>sfmodel_predict()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">sfmodel_predict( @eq(frontier), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@frontier-Tuple" href="#SFrontiers.@frontier-Tuple"><code>SFrontiers.@frontier</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@frontier(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the variables in the <code>frontier</code> function using column names from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec(@frontier(xvar1, xvar2, _cons), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@gamma-Tuple" href="#SFrontiers.@gamma-Tuple"><code>SFrontiers.@gamma</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@gamma(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the variables in the <code>gamma</code> function using column names from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec( @gamma(zvar, _cons), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@hscale-Tuple" href="#SFrontiers.@hscale-Tuple"><code>SFrontiers.@hscale</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@hscale(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the variables in the <code>hscale</code> function using column names from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec( @hscale(zvar, _cons), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@idvar-Tuple" href="#SFrontiers.@idvar-Tuple"><code>SFrontiers.@idvar</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@idvar(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code> for panel data models. Specify the column name of a DataFrame that contain the individual&#39;s id information of the panel data. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×4 DataFrame
│ Row │ year  │ firm  │ yvar  │ xvar1     │
│     │ Int64 │ Int64 │ Int64 │ Float64   │
├─────┼───────┼───────┼───────┼───────────┤
│ 1   │ 2019  │ 1     │ 1     │ 0.77645   │
│ 2   │ 2020  │ 1     │ 2     │ 0.0782388 │
│ 3   │ 2021  │ 1     │ 3     │ 0.222884  │
│ 4   │ 2022  │ 1     │ 4     │ 0.762864  │
⋮
│ 96  │ 2022  │ 24    │ 96    │ 0.590184  │
│ 97  │ 2019  │ 25    │ 97    │ 0.364425  │
│ 98  │ 2020  │ 25    │ 98    │ 0.639463  │
│ 99  │ 2021  │ 25    │ 99    │ 0.500526  │
│ 100 │ 2022  │ 25    │ 100   │ 0.239137  │

sfmodel_spec( @idvar(firm), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@mu-Tuple" href="#SFrontiers.@mu-Tuple"><code>SFrontiers.@mu</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@mu(arg::Vararg)</p><p>alias of @μ. See help on @μ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@sigma_a_2-Tuple" href="#SFrontiers.@sigma_a_2-Tuple"><code>SFrontiers.@sigma_a_2</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@sigma<em>a</em>2(arg::Vararg)</p><p>alias of @σₐ². See help on @σₐ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@sigma_u_2-Tuple" href="#SFrontiers.@sigma_u_2-Tuple"><code>SFrontiers.@sigma_u_2</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@sigma<em>u</em>2(arg::Vararg)</p><p>alias of @σᵤ². See help on @σᵤ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@sigma_v_2-Tuple" href="#SFrontiers.@sigma_v_2-Tuple"><code>SFrontiers.@sigma_v_2</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@sigma<em>v</em>2(arg::Vararg)</p><p>alias of @σᵥ². See help on @σᵥ².</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@timevar-Tuple" href="#SFrontiers.@timevar-Tuple"><code>SFrontiers.@timevar</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@timevar(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code> for panel data models. Specify the column name of a DataFrame that contain the time information of the panel data. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×4 DataFrame
│ Row │ year  │ firm  │ yvar  │ xvar1     │
│     │ Int64 │ Int64 │ Int64 │ Float64   │
├─────┼───────┼───────┼───────┼───────────┤
│ 1   │ 2019  │ 1     │ 1     │ 0.77645   │
│ 2   │ 2020  │ 1     │ 2     │ 0.0782388 │
│ 3   │ 2021  │ 1     │ 3     │ 0.222884  │
│ 4   │ 2022  │ 1     │ 4     │ 0.762864  │
⋮
│ 96  │ 2022  │ 24    │ 96    │ 0.590184  │
│ 97  │ 2019  │ 25    │ 97    │ 0.364425  │
│ 98  │ 2020  │ 25    │ 98    │ 0.639463  │
│ 99  │ 2021  │ 25    │ 99    │ 0.500526  │
│ 100 │ 2022  │ 25    │ 100   │ 0.239137  │

sfmodel_spec( @timvar(year), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@μ-Tuple" href="#SFrontiers.@μ-Tuple"><code>SFrontiers.@μ</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@μ(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the variables in the <code>μ</code> function using column names from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec( @μ(zvar, _cons), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@σᵤ²-Tuple" href="#SFrontiers.@σᵤ²-Tuple"><code>SFrontiers.@σᵤ²</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@σᵤ²(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the variables in the <code>σᵤ²</code> function using column names from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec( @σᵤ²(zvar, _cons), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@σᵥ²-Tuple" href="#SFrontiers.@σᵥ²-Tuple"><code>SFrontiers.@σᵥ²</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@σᵥ²(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the variables in the <code>σᵥ²</code> function using column names from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec( @σᵥ²(zvar, _cons), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.@σₐ²-Tuple" href="#SFrontiers.@σₐ²-Tuple"><code>SFrontiers.@σₐ²</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@σₐ²(arg::Vararg)</p><p>An argument in <code>sfmodel_sepc()</code>. Specify the variables in the <code>σₐ²</code> function using column names from a DataFrame. </p><p>See the help on <code>sfmodel_spec()</code> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df
100×5 DataFrame
│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │
│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │
├─────┼───────┼───────────┼───────────┼───────────┼─────────┤
│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │
│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │
│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │
│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │
⋮
│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │
│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │
│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │
│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │
│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │

sfmodel_spec( @σₐ²(_cons), ...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfmodel_MixTable" href="#SFrontiers.sfmodel_MixTable"><code>SFrontiers.sfmodel_MixTable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sfmodel_MixTable(&lt;keyword arguments&gt;)</code></pre><p>Display and return critical values of the mixed <code>χ²</code> (ch-square) distribution. The values are taken from Table 1, Kodde and Palm (1986, Econometrica).</p><p><strong>Argument</strong></p><ul><li><code>dof::Integer</code>: the degree of freedom. Currently support <code>dof</code> between 1 and 40.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sfmodel_MixTable(3)

  * Significance levels and critical values of the mixed χ² distribution
┌─────┬───────┬───────┬───────┬────────┐
│ dof │  0.10 │  0.05 │ 0.025 │   0.01 │
├─────┼───────┼───────┼───────┼────────┤
│ 3.0 │ 5.528 │ 7.045 │ 8.542 │ 10.501 │
└─────┴───────┴───────┴───────┴────────┘

source: Table 1, Kodde and Palm (1986, Econometrica).</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SFrontiers.sfmodel_predict-Tuple{Vector{Symbol}}" href="#SFrontiers.sfmodel_predict-Tuple{Vector{Symbol}}"><code>SFrontiers.sfmodel_predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sfmodel_predict(@eq(eq_name), data::DataFrame)</code></pre><p>Return predicted values of an equation (<code>eq_name</code>) of a stochastic frontier model specified and estimated by <code>sfmodel_spec()</code> and <code>sfmodel_fit()</code> .</p><p><strong>Arguments:</strong></p><ul><li><code>@eq(eq_name)</code>: where <code>eq_name</code> is the name of the equation to which the  value is to be predicted. A SF model has various equations, and different  SF models have different sets of equations. Eligible <code>eq_name</code>s follow  those specified in <code>sfmodel_spec()</code>. The <code>eq_name</code> may be specified using  unicodes or their alias names; viz., <code>@eq(σᵤ²)</code> is the same as  <code>@eq(sigma_u_2)</code>. Also, <code>log_σᵤ²</code> = <code>log_sigma_u_2</code>, <code>σᵥ²</code>= <code>sigma_v_2</code>,  <code>log_σᵥ²</code> = <code>log_sigma_v_2</code>, <code>σₐ²</code>= <code>sigma_a_2</code>, <code>log_σₐ²</code> = <code>log_sigma_a_2</code>,  and <code>μ</code> = <code>mu</code>.</li><li><code>data::DataFrame</code>: the DataFrame used in <code>sfmodel_fit()</code>. The DataFrame is required only when Method 1 is used in specifying <code>sfmodel_spec()</code>. If Method 2 is used instead, do not need this argument. See the help of <code>sfmodel_spec()</code> for the information on Method 1 and Method 2.</li></ul><p><strong>Remarks:</strong></p><p>The predicted value is computed based on the equation&#39;s variable list and the estimated coefficient vector. For instance, if the <code>frontier</code> function is a linear function of variables <code>X</code> and coefficient vector <code>β</code>, <code>sfmodel_predict(@eq(frontier), df)</code> returns <code>X*β̂</code>. If the variance function <code>σᵤ²</code> is parameterized by an exponential function of <code>Z</code> and <code>δ</code> (i.e., <code>σᵤ² = exp(Zδ)</code>), <code>sfmodel_predict(@eq(log_σᵤ²))</code> returns <code>Z*δ̂</code> and <code>sfmodel_predict(@eq(σᵤ²))</code> returns <code>exp(Z*δ̂)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">frontier_hat = sfmodel_predict(@eq(frontier), df);
sigma_u_2_hat = sfmodel_predict(@eq(σᵤ²), df);</code></pre></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="api.html#SFrontiers.all_init-Tuple{Vector{T} where T}"><code>SFrontiers.all_init</code></a></li><li><a href="api.html#SFrontiers.banner"><code>SFrontiers.banner</code></a></li><li><a href="api.html#SFrontiers.depvar-Tuple"><code>SFrontiers.depvar</code></a></li><li><a href="api.html#SFrontiers.frontier-Tuple{Vector{T} where T}"><code>SFrontiers.frontier</code></a></li><li><a href="api.html#SFrontiers.frontier-Tuple"><code>SFrontiers.frontier</code></a></li><li><a href="api.html#SFrontiers.gamma-Tuple"><code>SFrontiers.gamma</code></a></li><li><a href="api.html#SFrontiers.gamma-Tuple{Vector{T} where T}"><code>SFrontiers.gamma</code></a></li><li><a href="api.html#SFrontiers.hscale-Tuple"><code>SFrontiers.hscale</code></a></li><li><a href="api.html#SFrontiers.hscale-Tuple{Vector{T} where T}"><code>SFrontiers.hscale</code></a></li><li><a href="api.html#SFrontiers.idvar-Tuple"><code>SFrontiers.idvar</code></a></li><li><a href="api.html#SFrontiers.ineff_index"><code>SFrontiers.ineff_index</code></a></li><li><a href="api.html#SFrontiers.main_maxIT"><code>SFrontiers.main_maxIT</code></a></li><li><a href="api.html#SFrontiers.main_solver"><code>SFrontiers.main_solver</code></a></li><li><a href="api.html#SFrontiers.marginal"><code>SFrontiers.marginal</code></a></li><li><a href="api.html#SFrontiers.mu-Tuple"><code>SFrontiers.mu</code></a></li><li><a href="api.html#SFrontiers.mu-Tuple{Vector{T} where T}"><code>SFrontiers.mu</code></a></li><li><a href="api.html#SFrontiers.sfdist-Tuple"><code>SFrontiers.sfdist</code></a></li><li><a href="api.html#SFrontiers.sfmodel_MixTable"><code>SFrontiers.sfmodel_MixTable</code></a></li><li><a href="api.html#SFrontiers.sfmodel_boot_marginal-Tuple{}"><code>SFrontiers.sfmodel_boot_marginal</code></a></li><li><a href="api.html#SFrontiers.sfmodel_fit-Tuple{}"><code>SFrontiers.sfmodel_fit</code></a></li><li><a href="api.html#SFrontiers.sfmodel_init-Tuple"><code>SFrontiers.sfmodel_init</code></a></li><li><a href="api.html#SFrontiers.sfmodel_opt-Tuple"><code>SFrontiers.sfmodel_opt</code></a></li><li><a href="api.html#SFrontiers.sfmodel_predict-Tuple{Vector{Symbol}}"><code>SFrontiers.sfmodel_predict</code></a></li><li><a href="api.html#SFrontiers.sfmodel_spec-Tuple"><code>SFrontiers.sfmodel_spec</code></a></li><li><a href="api.html#SFrontiers.sftype-Tuple"><code>SFrontiers.sftype</code></a></li><li><a href="api.html#SFrontiers.sigma_a_2-Tuple"><code>SFrontiers.sigma_a_2</code></a></li><li><a href="api.html#SFrontiers.sigma_a_2-Tuple{Vector{T} where T}"><code>SFrontiers.sigma_a_2</code></a></li><li><a href="api.html#SFrontiers.sigma_u_2-Tuple"><code>SFrontiers.sigma_u_2</code></a></li><li><a href="api.html#SFrontiers.sigma_u_2-Tuple{Vector{T} where T}"><code>SFrontiers.sigma_u_2</code></a></li><li><a href="api.html#SFrontiers.sigma_v_2-Tuple{Vector{T} where T}"><code>SFrontiers.sigma_v_2</code></a></li><li><a href="api.html#SFrontiers.sigma_v_2-Tuple"><code>SFrontiers.sigma_v_2</code></a></li><li><a href="api.html#SFrontiers.table_format"><code>SFrontiers.table_format</code></a></li><li><a href="api.html#SFrontiers.timevar-Tuple"><code>SFrontiers.timevar</code></a></li><li><a href="api.html#SFrontiers.tolerance"><code>SFrontiers.tolerance</code></a></li><li><a href="api.html#SFrontiers.useData-Tuple{DataFrames.DataFrame}"><code>SFrontiers.useData</code></a></li><li><a href="api.html#SFrontiers.verbose"><code>SFrontiers.verbose</code></a></li><li><a href="api.html#SFrontiers.warmstart_maxIT"><code>SFrontiers.warmstart_maxIT</code></a></li><li><a href="api.html#SFrontiers.warmstart_solver"><code>SFrontiers.warmstart_solver</code></a></li><li><a href="api.html#SFrontiers.μ-Tuple"><code>SFrontiers.μ</code></a></li><li><a href="api.html#SFrontiers.μ-Tuple{Vector{T} where T}"><code>SFrontiers.μ</code></a></li><li><a href="api.html#SFrontiers.σᵤ²-Tuple"><code>SFrontiers.σᵤ²</code></a></li><li><a href="api.html#SFrontiers.σᵤ²-Tuple{Vector{T} where T}"><code>SFrontiers.σᵤ²</code></a></li><li><a href="api.html#SFrontiers.σᵥ²-Tuple{Vector{T} where T}"><code>SFrontiers.σᵥ²</code></a></li><li><a href="api.html#SFrontiers.σᵥ²-Tuple"><code>SFrontiers.σᵥ²</code></a></li><li><a href="api.html#SFrontiers.σₐ²-Tuple"><code>SFrontiers.σₐ²</code></a></li><li><a href="api.html#SFrontiers.σₐ²-Tuple{Vector{T} where T}"><code>SFrontiers.σₐ²</code></a></li><li><a href="api.html#SFrontiers.@depvar-Tuple"><code>SFrontiers.@depvar</code></a></li><li><a href="api.html#SFrontiers.@eq-Tuple{Any}"><code>SFrontiers.@eq</code></a></li><li><a href="api.html#SFrontiers.@frontier-Tuple"><code>SFrontiers.@frontier</code></a></li><li><a href="api.html#SFrontiers.@gamma-Tuple"><code>SFrontiers.@gamma</code></a></li><li><a href="api.html#SFrontiers.@hscale-Tuple"><code>SFrontiers.@hscale</code></a></li><li><a href="api.html#SFrontiers.@idvar-Tuple"><code>SFrontiers.@idvar</code></a></li><li><a href="api.html#SFrontiers.@mu-Tuple"><code>SFrontiers.@mu</code></a></li><li><a href="api.html#SFrontiers.@sigma_a_2-Tuple"><code>SFrontiers.@sigma_a_2</code></a></li><li><a href="api.html#SFrontiers.@sigma_u_2-Tuple"><code>SFrontiers.@sigma_u_2</code></a></li><li><a href="api.html#SFrontiers.@sigma_v_2-Tuple"><code>SFrontiers.@sigma_v_2</code></a></li><li><a href="api.html#SFrontiers.@timevar-Tuple"><code>SFrontiers.@timevar</code></a></li><li><a href="api.html#SFrontiers.@μ-Tuple"><code>SFrontiers.@μ</code></a></li><li><a href="api.html#SFrontiers.@σᵤ²-Tuple"><code>SFrontiers.@σᵤ²</code></a></li><li><a href="api.html#SFrontiers.@σᵥ²-Tuple"><code>SFrontiers.@σᵥ²</code></a></li><li><a href="api.html#SFrontiers.@σₐ²-Tuple"><code>SFrontiers.@σₐ²</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ex_panel.html">« panel models</a><a class="docs-footer-nextpage" href="LICENSE.html">License »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Tuesday 7 September 2021 18:35">Tuesday 7 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
