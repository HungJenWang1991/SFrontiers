var documenterSearchIndex = {"docs":
[{"location":"api.html#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Modules = [SFrontiers]\r\nPages   = [\"SFmainfun.jl\", \"SFmacfun.jl\", \"SFcheck.jl\", \"SFpredict.jl\", \"SFgetvars.jl\"]","category":"page"},{"location":"api.html#SFrontiers.sfmodel_CI-Tuple{}","page":"API Reference","title":"SFrontiers.sfmodel_CI","text":"function sfmodel_CI(; bootdata::Any=nothing, observed::Union{Vector, Real, Tuple, NamedTuple}=nothing, level::Real=0.05, verbose::Bool=true)\n\nsfmodel_CI(<keyword arguments>)\n\nA general purpose (not specific to stochastic frontier models) function for obtaining bias-correctred (BC) confidence intervals from bootstrapped data. Return a K x 1 matrix of confidence intervals in the form of tuples, where K is the number of bootstrap statistics.\n\nSee also the help file on sfmodel_boot_marginal().\n\nArguments\n\nbootdata::Array=<data>: The bootstrapped data of size R x K, where R is the number of bootstrap samples (replications) and K is the number of statistics. An example is the bootstrapped data from sfmodel_boot_marginal(, ... getBootData=true).\nobserved::Union{Vector, Real, Tuple, NamedTuple}=<a vector of numbers>: The observed values of the statistics to which the confidence intervals are to be calculated. The length of observed should be equal to K. It could take the form of a single value (if K=1), a vector, a tuple, or a NamedTuple.\nlevel::Real=<number>: The significance level (default=0.05) of the bias-corrected confidence intervals. If level>0.5, it is automatically transformed to 1-level, such that level=0.05 and level=0.95 both return 95% confidene intervals at the 5% significance level.  \nverbose::Bool=true: Print the result.\n\nExamples\n\njulia> myans = sfmodel_fit(useData(df));\n\n (output omitted)\n\njulia> std_ci, bsdata = sfmodel_boot_marginal(result=myans, data=df, R=250, seed=123, getBootData=true);\n\n (output omitted)\n\njulia> sfmodel_CI(bootdata=bsdata, observed=myans.marginal_mean, level=0.10) \n\nBias-Corrected 90.0% Confidence Interval:\n \n3×1 Matrix{Any}:\n (-0.00655, 0.0009)\n (-0.04064, 0.0086)\n (-0.04663, -0.00872)\n\njulia> # manually input observed values\n\njulia> sfmodel_CI(bootdata=bsdata, observed=(-0.00264, -0.01197, -0.0265), level=0.10)\n \nBias-Corrected 90.0% Confidence Interval:\n \n3×1 Matrix{Any}:\n (-0.00655, 0.0009)\n (-0.04064, 0.0086)\n (-0.04663, -0.00872)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sfmodel_boot_marginal-Tuple{}","page":"API Reference","title":"SFrontiers.sfmodel_boot_marginal","text":"sfmodel_boot_marginal(<keyword arguments>)\n\nBootstrap standard errors and obtain bias-corrected (BC) confidence intervals for the mean marginal effects of inefficiency determinants. In default, return a K x 2matrix of standard errors (1st column) and confidence intervals (tuples, 2nd column), whereKis the number of exogenous inefficiency determinants. WithgetBootData=true, return two matrices: the first is the same as in the default return, and the second is theR x K` bootstrapped data.\n\nSee also the help file on sfmodel_CI().\n\nArguments\n\nresult=<returned result>: The returned result from sfmodel_fit().\ndata=<dataset>: The DataFrame dataset containing the model's data. Same as the one used in sfmodel_fit(). If the data was supplied by matrix (instead of DataFrame; i.e., the Method 2 of sfmodel_spec()), this option should be skipped.\nR::Integer=<number>: The number of bootstrapped samples. The default is 500.\nlevel::Real=<number>: The significance level (default=0.05) of the bias-corrected confidence intervals. If level>0.5, it is automatically transformed to 1-level, such that level=0.05 and level=0.95 both return 95% confidene intervals at the 5% significance level.\nseed::Integer=<number>: A postive integer used to seed the random number generator (rng) for resampling, which ensures reproducibility. This rng is not global and is only effective in this function. If not specified, the global random number generator is used, and the bootstrap result may change (slightly) between different runs.\niter::Integer=<number>: The maximum number of iterations for each bootstrapped sample. If the number is larger than 0, it overwrites the main_maxIT  specified in sfmodel_opt() which is the default.\ngetBootData::Bool=false: Whether to return the bootstrapped data which is R x K where K is the number of exogenous determinants of inefficiency.\nevery::Integer=10: Print bootstrapping progress for every every samples.\n\nRemarks\n\nBootstrap samples are with replacement. For panel data, it samples cross-sectional units with replacement.\nIn the MLE estimation, estimated coefficients from the main result is used as initial values. There is no warmstart. The main_solver, main_maxIT, and tolerance specified in sfmodel_opt() are used as default, but the value of main_maxIT may be replaced by the iter option.\n\nExamples\n\njulia> std_ci = sfmodel_boot_marginal(result=res, data=df, R=250, seed=123)\nbootstrap in progress..10..20..30..40..50..60..70..80..90..100..110..120..130..140..150..160..170..180..190..200..210..220..230..240..250..Done!\n\n┌────────┬──────────────────────┬─────────────────┬──────────────────────┐\n│        │ mean of the marginal │ std.err. of the │       bias-corrected │\n│        │       effect on E(u) │     mean effect │    95.0%  conf. int. │\n├────────┼──────────────────────┼─────────────────┼──────────────────────┤\n│    age │             -0.00264 │         0.00225 │   (-0.00734, 0.0016) │\n│ school │             -0.01197 │         0.01765 │    (-0.048, 0.01224) │\n│     yr │             -0.02650 │         0.01221 │ (-0.05257, -0.00447) │\n└────────┴──────────────────────┴─────────────────┴──────────────────────┘\n\n3×2 Matrix{Any}:\n 0.00224786  (-0.00734, 0.0016)\n 0.0176472   (-0.048, 0.01224)\n 0.012213    (-0.05257, -0.00447)\n\njulia> std_ci, bsdata = sfmodel_boot_marginal(result=res, data=df, R=250, seed=123, getBootData=true);\n\n (output omitted)\n\njulia> bsdata\n250×3 adjoint(::Matrix{Real}) with eltype Real:\n-0.000493033  -0.00840051   -0.0339088\n-0.00510175   -0.0128184    -0.0147759\n-0.0024987    -0.00971428   -0.00989262\n-0.00157346   -0.0265515    -0.0140001\n-0.00352179   -0.00670365   -0.0246122\n-0.00375162   -0.0070496    -0.0306034\n-0.00153094   -0.0154201    -0.0367731\n0.000149329   0.00672036   -0.0461389\n⋮\n-0.00373306   -0.0108364    -0.00871898\n-0.00170254   -0.0393002    -0.0500638\n0.000686169   0.00241594   -0.018542\n0.000258745   0.000183392  -0.039621\n-0.00408104   -0.014574     -0.024126\n-0.00417206   -0.0192443    -0.0406959\n0.00266017   -0.0396552    -0.0359759\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sfmodel_fit-Tuple{}","page":"API Reference","title":"SFrontiers.sfmodel_fit","text":"sfmodel_fit(<keyword arguments>)\n\nMaximum likelihood estimation of the stochastic frontier model specified  in sfmodel_spec(...). Estimate the model parameters, calculate Jondrow et al.  (1982) inefficiency index and Battese and Coelli (1988) efficiency index,  compute marginal effects of inefficiency determinants (if any). Return a dictionary with results.\n\nArguments\n\nuseData(::DataFrame): The DataFrame used with the Method 1 of sfmodel_spec(...). If use Method 2 of sfmodel_spec(...) (viz., data is supplied by individual matrices), do not need this keyword argument.\n\nRemarks\n\nUse Optim.jl to carry out the estimation.\nUsers do not need to provide gradient or Hessian functions even if  gradient-based optimization algorithms are used. The package uses automatic differentiation (https://en.wikipedia.org/wiki/Automatic_differentiation) to  compute the derivatives. AD is not numerical finite differentiation. AD is fast and as accurate as the symbolic differentiation.\n\nExamples\n\nsfmodel_fit(useData(df))    # Method 1\nsfmodel_fit()               # Method 2\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sfmodel_init-Tuple","page":"API Reference","title":"SFrontiers.sfmodel_init","text":"sfmodel_init(<keyword arguments>)\n\nProvide initial values for the stochastic frontier model estimation. The values could be a vector or scalars. It creates a global dictionary _dicINI. Optional.\n\nArguments\n\nall_init(::Union{Vector, Real}): initial values of all the parameters in the model\nfrontier(::Union{Vector, Real}): initial values of parameters in the frontier() function\nμ(::Union{Vector, Real}) or mu(::Union{Vector, Real}): initial values of parameters in the μ function\nhscale(::Union{Vector, Real}): initial values of parameters in the hscale() function\ngamma(::Union{Vector, Real}): initial values of parameters in the gamma() function\nσᵤ²(::Union{Vector, Real}) or sigma_u_2(::Union{Vector, Real}): initial values of parameters in the  σᵤ² function\nσᵥ²(::Union{Vector, Real}) or sigma_v_2(::Union{Vector, Real}): initial values of parameters in the  σᵥ² function    \nσₐ²(::Union{Vector, Real}) or sigma_a_2(::Union{Vector, Real}): initial values of parameters in the σₐ² function\nmessage::Bool: Whether printing (=true) or not (=false, the default) the confirmation message \"A dictionary from sfmodelinit() is generated.\" on the screen after `sfmodelinit()` is successfully executed.\n\nRemarks\n\nEquations do not have to follow specific orders.\nsfmodel_init(...) is optional but is highly recommended. If it is not specified or is specified as an empty set, default values are used.\nIt is not necessary to specify a complete set of equations. A partial list  or even empty lists are acceptable. Default values will be substituted for the missing equations.\nThe generated _dicINI is inheritable in the sense that an exiting _dicINI (from the previous run of the same or a different model, for example) will be used if the current model does not have its own sfmodel_init(...). This design has advantages in a simulations study where sfmodel_init(...) needs to be specified only once.\n\nExamples\n\nb_ini = ones(2)*0.2\nsfmodel_init( # frontier(bb),             # may skip and use default\n             μ(b_ini),                    # may use a vector\n             σᵤ²(-0.1, -0.1),  \n             σᵥ²(-0.1) )                   \n\nsfmodel_init(all_init(0.1, 0.2, 0.5, 0.0, -0.1, -0.1, -0.1),\n             message = false)             \n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sfmodel_opt-Tuple","page":"API Reference","title":"SFrontiers.sfmodel_opt","text":"sfmodel_opt(<keyword arguments>)\n\nProvide options to the optimization algorithms for the maiximum likelihood estimation. It creates a global dictionary _dicOPT. Optional. The Optim package is used for the optimization, and a subset of Optim's keywords are directly accessible from this API. \n\nArguments\n\nwarmstart_solver(algorithm): The algorithm used in the first-stage (\"warmstart\") optimization process, which serves the purpose of improving upon the initial values for the second-stage (\"main\") estimation. The default is NelderMead(). Others include SimulatedAnnealing(), SAMIN(), ParticleSwarm(), ConjugateGradient(), GradientDescent(), BFGS(), LBFGS(), Newton(), NewtonTrustRegion(), and IPNewton(). See http://julianlsolvers.github.io/Optim.jl/stable/ for details. Non-gradient based algorithms are recommended for the warmstart solver. \nwarmstart_maxIT(::Int64): The iteration limit for the warmstart. Default is 100.\nmain_solver(algorithm): The algorithm used in the main opimization process. The default is Newton(). Others include SimulatedAnnealing(), SAMIN(), ParticleSwarm(), ConjugateGradient(), GradientDescent(), BFGS(), LBFGS(), NewtonTrustRegion(), and IPNewton(). See http://julianlsolvers.github.io/Optim.jl/stable/ for details.\nmain_maxIT(::Int64): The iteration limit for the main estimation. Default is 2000.\ntolerance(::Float64): The convergence criterion (\"tolerance\") based on the absolute value of gradients. Default is 1.0e-8. For non-gradient algorithms, it controls the main convergence tolerance, which is solver specific.  See Optim's g_tol option for more information.\nverbose(::Bool): Print on screen (true, the default) the information of the model and the optimization results.\nbanner(::Bool): Print on screen (true, the default) a banner to serve as a visual indicator of the start of the estimation.\nineff_index(::Bool): Whether to compute the Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1988) efficiency index. The defauis true.\nmarginal(::Bool): Whether to compute the marginal effects of the exogenous determinants of inefficiency (if any).\ntable_format(): The format to print the coefficient tables on the screen: text (default), html, or latex. A wrapper of PrettyTables.jl's backend option.\nmessage::Bool: Whether printing (=true) or not (=false, the default) the confirmation message \"A dictionary from sfmodelopt() is generated.\" on the screen after `sfmodelopt()` is successfully executed.\n\nRemarks\n\nsfmodel_opt(...) is optional. It can be omitted entirely, or specifying only a partial list of the keywords.\nIf any of the keywords are missing, default values are used.\nIf warmstart is not needed, you need to give empty keyword values to warmstart related keys. E.g., either warmstart_solver() or warmstart_maxIT(), or both. Omitting the keyword entirely (i.e., not writing down warmstart_solver or warmstart_maxIT) will not skip the warmstart, but will reinstate the default. \nUsers do not need to provide gradient or Hessian functions even if  gradient-based optimization algorithms are used. The package uses automatic differentiation (https://en.wikipedia.org/wiki/Automatic_differentiation) to  compute the derivatives. It is not numerical finite differentiation. It is fast and as accurate as the symbolic differentiation.\nThe _dicOPT is inheritable in the sense that an exiting _dicOPT (from the previous run of the same or a different model, for example) will be used if the current model does not have its own sfmodel_opt(...). This design has advantages in simulation studies where sfmodel_opt(...) needs to be specified only once.\n\nExamples\n\nsfmodel_opt(warmstart_solver(NelderMead()),   \n            warmstart_maxIT(200),\n            main_solver(Newton()), \n            main_maxIT(2000), \n            tolerance(1e-8),\n            message = false)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sfmodel_spec-Tuple","page":"API Reference","title":"SFrontiers.sfmodel_spec","text":"sfmodel_spec(<keyword arguments>)\n\nProvide specifications of the stochastic frontier model, including the type of model and names of variables or matrix used in estimating the model. Two ways to specify: Method 1: Use DataFrame as input, and Method 2: use matrix as input.\n\nMethod 1 (DataFrame input)\n\nVariables come from a DataFrame, and column names of the Dataframe are used in the variable input. With this method, equations are identified by macros but not functions (e.g., @depvar() but not depvar()).\n\nArguments of Method 1\n\nsfdist(::Vararg): the distribution assumption of the one-sided stochastic variable (aka inefficiency term) of the model; possible choices include truncated (or trun, t), half (or h), exponential (or expo, e), and trun_scale (or trun_scaling, ts).\nsftype(::Vararg): whether the model is a production (or prod) frontier or a cost frontier.\nsfpanel(::Vararg): the type of panel model. Choices include FE_WH2010 (true fixed effect model of Wang and Ho 2010 JE), TFE_CSW2014 (true fixed model of Chen, Schmidt, and Wang 2014 JE),  TRE (true random effect model of Greene 2004), TimeDecay (time decay model of Battese and Coelli 1992).\n@depvar(::Vararg): the dependent variable from a DataFrame.\n@frontier(::Vararg): a list of variables, separated by commas, in the frontier function.\n@μ(::Vararg) or @mu(::Vararg): a list of variable, separated by comma, in the linear function of μ. (sftype(trun) only).\n@σᵥ²(::Vararg) or @sigma_v_2(::Vararg): a list of variable, separated by comma, in the σᵥ² equation.\n@σᵤ²(::Vararg) or @sigma_u_2(::Vararg): a list of variable, separated by comma, in the σᵤ² equation.\n@σₐ²(::Vararg) or @sigma_a_2(::Vararg): a list of variable, separated by comma, in the σₐ² equation. sfpanel(TRE) only.\n@gamma(::Vararg): a list of variables, separated by commas, in the gamma equation. sfpanel(TimeDecay) only.\n@timevar(::Vararg): the variable containing the time period information. Panel data model only.\n@idvar(::Vararg): the variable identifying each individual. Panel data model only.\nmessage::Bool: Whether printing (=true) or not (=false, the default) the confirmation message \"A dictionary from sfmodelspec() is generated.\" on the screen after `sfmodelspec()` is successfully executed.  \n\nMethod 2 (matrix/vector input)\n\nData of the variables are provided by individual matrices or vectors, and names of the mat/vec are used in the equations. With this method, equations are identified by functions but not macros (e.g., depvar() but not @depvar()). Note that if, for instance, the name of depvar or σᵤ² has been used elsewhere in the program, using these names to read in mat/vec will cause name conflict (MethodError: objects of type ... are not callable). The workaround is to fully qualify the function names, e.g., SFrontiers.depvar, SFrontiers.σᵤ², etc. Or, use the alias (if available), e.g., sigma_u_2 instead of σᵤ².\n\nArguments of Method 2\n\nsfdist(::Vararg): the distribution assumption on the inefficiency term; possible choices include truncated (or trun, t), half (or h), exponential (or expo, e), and trun_scale (or trun_scaling, ts).\nsftype(::Vararg): whether the model is a production (or prod) frontier or a cost frontier.\nsfpanel(::Vararg): the type of panel model. Choices include FE_WH2010 (true fixed effect model of Wang and Ho 2010 JE), TFE_CSW2014 (true fixed model of Chen, Schmidt, and Wang 2014 JE),  TRE (true random effect model of Greene 2004), TimeDecay (time decay model of Battese and Coelli 1992).\ndepvar(::Matrix): Matrix or vector of the dependent variable.\nfrontier(::Matrix): matrix or vector for frontier function.\nμ(::Matrix) or mu(::Matrix): matrix or vector for the (linear) μ equation (trun type only).\nσᵤ²(::Matrix) or sigma_u_2(::Matrix): matrix or vector for the σᵤ² equation.\nσₐ²(::Matrix) or sigma_a_2(::Matrix): matrix or vector for the σₐ² equation.\nmessage::Bool: Whether printing (=true) or not (=false, the default) the confirmation message \"A dictionary from sfmodelspec() is generated.\" on the screen after `sfmodelspec()` is successfully executed.\n\nExamples\n\nsfmodel_spec(sftype(prod), sfdist(trun),\n             @depvar(output), \n             @frontier(land, , labor, bull, year, _cons), \n             @μ(age, school, year, _cons),\n             @σᵤ²(age, school, year, _cons),\n             @σᵥ²(_cons));\n\nsfmodel_spec(sfpanel(TRE), sftype(prod), sfdist(half),\n             @timevar(yr), @idvar(id),\n             @depvar(y), \n             @frontier(x1, x2, _cons), \n             @σₐ²(_cons),\n             @σᵤ²(_cons),\n             @σᵥ²(_cons),\n             message = false);\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.all_init-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.all_init","text":"all_init(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for all the parameters in the model.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init( all_init(0.1, 0.2, 0.5, -0.1, -0.1, -0.2), ...)\n\nb0 = ones(6)*0.1\nsfmodel_init( all_init(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.banner","page":"API Reference","title":"SFrontiers.banner","text":"banner(arg::Bool)\n\nAn argument in sfmodel_opt(). Specify whether to print on screen (true, the default) a banner to serve as a visual indicator of the start of the  estimation.\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\nsfmodel_opt( banner(false), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.depvar-Tuple","page":"API Reference","title":"SFrontiers.depvar","text":"depvar(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the maxrix name where the matrix is used as the data of the dependent variable.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> ymat\n100×1 Matrix{Float64}:\n  0.0005852467656204083\n -0.9128698116696892\n -1.1087862468093093\n -1.0714018769972091\n -0.606943663382492\n  0.37648407866805467\n -0.1281971631844683\n  ⋮\n  0.8541895741866585\n  1.5109216952026845\n -0.3519833126683764\n -1.0378799750720447\n -0.9990384371507885\n  0.18858962788775305\n\nsfmodel_spec(depvar(ymat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.frontier-Tuple","page":"API Reference","title":"SFrontiers.frontier","text":"frontier(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the name of the maxrix used as the data of the frontier function.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> xmat\n100×3 Matrix{Float64}:\n -0.682942    0.440045   1.0\n -0.680902   -1.68124    1.0\n  1.29108    -1.5516     1.0\n  0.683652   -0.0319451  1.0\n -0.973079    1.11636    1.0\n -0.343229    0.314457   1.0\n  0.107583    0.688177   1.0\n  ⋮\n  0.0943377  -0.781928   1.0\n -0.599142   -1.01591    1.0\n -0.56726    -1.03394    1.0\n  1.33522     0.135763   1.0\n  1.13235     0.0177493  1.0\n -0.310638   -0.314166   1.0\n\nsfmodel_spec(frontier(xmat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.frontier-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.frontier","text":"frontier(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for coefficients in the frontier function.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init(frontier(0.1, 0.2, 0.5), ...)\nb0 = ones(3)*0.1\nsfmodel_init( frontier(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.gamma-Tuple","page":"API Reference","title":"SFrontiers.gamma","text":"gamma(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the name of the maxrix used as the data of the gamma function.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> gmat\n100×2 Matrix{Float64}:\n -0.943133   1.0\n -0.897392   1.0\n  0.585447   1.0\n -0.46106    1.0\n -0.54563    1.0\n -0.619428   1.0\n  0.0575559  1.0\n  ⋮\n  0.0844192  1.0\n -1.3339     1.0\n  1.29332    1.0\n  0.691466   1.0\n  0.422962   1.0\n  0.374425   1.0\n\nsfmodel_spec(gamma(gmat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.gamma-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.gamma","text":"gamma(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for coefficients in the gamma function.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init( gamma(0.1, 0.2, 0.5), ...)\n\nb0 = ones(3)*0.1\nsfmodel_init( gamma(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.hscale-Tuple","page":"API Reference","title":"SFrontiers.hscale","text":"hscale(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the name of the maxrix used as the data of the hscale function.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> hmat\n100×2 Matrix{Float64}:\n -0.943133   1.0\n -0.897392   1.0\n  0.585447   1.0\n -0.46106    1.0\n -0.54563    1.0\n -0.619428   1.0\n  0.0575559  1.0\n  ⋮\n  0.0844192  1.0\n -1.3339     1.0\n  1.29332    1.0\n  0.691466   1.0\n  0.422962   1.0\n  0.374425   1.0\n\nsfmodel_spec(hscale(hmat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.hscale-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.hscale","text":"hscale(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for coefficients in the hscale function.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init( hscale(0.1, 0.2, 0.5), ...)\n\nb0 = ones(3)*0.1\nsfmodel_init( hscale(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.idvar-Tuple","page":"API Reference","title":"SFrontiers.idvar","text":"idvar(arg::Vararg)\n\nAn argument in sfmodel_sepc() for panel data models. Specify the name of the matrix containing the individual's id information of the panel data. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> idmat\n100-element Vector{Int64}:\n  1\n  1\n  1\n  1\n  2\n  2\n  2\n  ⋮\n 24\n 24\n 25\n 25\n 25\n 25\n\nsfmodel_spec( idvar(idmat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.ineff_index","page":"API Reference","title":"SFrontiers.ineff_index","text":"ineff_index(arg::Bool)\n\nAn argument in sfmodel_opt(). Specify whether (true, the default) to compute the Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1988) efficiency index.\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\nsfmodel_opt( ineff_index(false), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.main_maxIT","page":"API Reference","title":"SFrontiers.main_maxIT","text":"main_maxIT(arg)\n\nAn argument in sfmodel_opt(). Specify the iteration limit for the main solver. Default  is 2000.\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\njulia-repl  sfmodel_opt( main_maxIT(2500), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.main_solver","page":"API Reference","title":"SFrontiers.main_solver","text":"main_solver(arg)\n\nAn argument in sfmodel_opt(). Specify the algorithm used in the 2nd-stage (\"main\")   optimization process.\n\nThe default is Newton(). Others include SimulatedAnnealing(), SAMIN(), ParticleSwarm(),   ConjugateGradient(), GradientDescent(), BFGS(), LBFGS(),   NewtonTrustRegion(), and IPNewton(). See   http://julianlsolvers.github.io/Optim.jl/stable/ for details.\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\nsfmodel_opt( main_solver(Newton()), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.marginal","page":"API Reference","title":"SFrontiers.marginal","text":"marginal(arg::Bool)\n\nAn argument in sfmodel_opt(). Specify whether (true, the default) to  compute the marginal effects of the exogenous determinants of inefficiency (if any).\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\njulia-repl  sfmodel_opt( marginal(false), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.mu-Tuple","page":"API Reference","title":"SFrontiers.mu","text":"mu(arg::Vararg)\n\nalias of μ. See help on μ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.mu-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.mu","text":"mu(arg::Vector)\n\nalias of μ. See help on μ.\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sfdist-Tuple","page":"API Reference","title":"SFrontiers.sfdist","text":"sfdist(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the distribution assumption of the one-sided stochastic variable (aka inefficiency term) of the model. Possible choices include truncated (or trun, t), half (or h), exponential (or expo, e), and trun_scale (or trun_scaling, ts).\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\nsfmodel_spec(sfdist(t), ...)\nsfmodel_spec(sfdist(h), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sftype-Tuple","page":"API Reference","title":"SFrontiers.sftype","text":"sftype(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify whether the model is a production (or prod) frontier or a cost frontier.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\nsftype(production)\nsftype(cost)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sigma_a_2-Tuple","page":"API Reference","title":"SFrontiers.sigma_a_2","text":"sigmaa2(arg::Vararg)\n\nalias of σₐ². See help on σₐ².\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sigma_a_2-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.sigma_a_2","text":"sigmaa2(arg::Vector)\n\nalias of σₐ². See help on σₐ².\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sigma_u_2-Tuple","page":"API Reference","title":"SFrontiers.sigma_u_2","text":"sigmau2(arg::Vararg)\n\nalias of σᵤ². See help on σᵤ².\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sigma_u_2-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.sigma_u_2","text":"sigmau2(arg::Vector)\n\nalias of σᵤ². See help on σᵤ².\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sigma_v_2-Tuple","page":"API Reference","title":"SFrontiers.sigma_v_2","text":"sigmav2(arg::Vararg)\n\nalias of σᵥ². See help on σᵥ².\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.sigma_v_2-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.sigma_v_2","text":"sigmav2(arg::Vector)\n\nalias of σᵥ². See help on σᵥ².\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.table_format","page":"API Reference","title":"SFrontiers.table_format","text":"table_format(arg)\n\nAn argument in sfmodel_opt(). Specify the format to print the coefficient  tables on the screen: text (default), html, or latex. A wrapper of PrettyTables.jl's  backend option.\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\njulia-repl  sfmodel_opt( table_format(html), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.timevar-Tuple","page":"API Reference","title":"SFrontiers.timevar","text":"timevar(arg::Vararg)\n\nAn argument in sfmodel_sepc() for panel data models. Specify the name of the matrix containing the time information of the panel data. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> timemat\n100-element Vector{Int64}:\n 2019\n 2020\n 2021\n 2022\n 2019\n 2020\n 2021\n    ⋮\n 2021\n 2022\n 2019\n 2020\n 2021\n 2022\n\nsfmodel_spec( timvar(timemat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.tolerance","page":"API Reference","title":"SFrontiers.tolerance","text":"tolerance(arg::Float64)\n\nAn argument in sfmodel_opt(). Specify the convergence criterion (\"tolerance\") based on the absolute value of gradients. Default is 1.0e-8. For non-gradient algorithms, it controls the main convergence tolerance, which is solver specific.  See Optim's g_tol option for more information.\n\nAlso see the help on sfmodel_opt() for more information.\n\nExamples\n\nsfmodel_opt( tolerance(1.0e-6), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.useData-Tuple{DataFrames.DataFrame}","page":"API Reference","title":"SFrontiers.useData","text":"useData(D::DataFrame)\n\nAn argument in sfmodel_fit(). Specify the name of the DataFrame that   contains the estimation data.\n\nSee the help on sfmodel_fit() for more information.\n\nExamples\n\n  julia> mydf\n  100×4 DataFrame\n  │ Row │ year  │ firm  │ yvar  │ xvar1     │\n  │     │ Int64 │ Int64 │ Int64 │ Float64   │\n  ├─────┼───────┼───────┼───────┼───────────┤\n  │ 1   │ 2019  │ 1     │ 1     │ 0.77645   │\n  │ 2   │ 2020  │ 1     │ 2     │ 0.0782388 │\n  │ 3   │ 2021  │ 1     │ 3     │ 0.222884  │\n  │ 4   │ 2022  │ 1     │ 4     │ 0.762864  │\n  ⋮\n  │ 96  │ 2022  │ 24    │ 96    │ 0.590184  │\n  │ 97  │ 2019  │ 25    │ 97    │ 0.364425  │\n  │ 98  │ 2020  │ 25    │ 98    │ 0.639463  │\n  │ 99  │ 2021  │ 25    │ 99    │ 0.500526  │\n  │ 100 │ 2022  │ 25    │ 100   │ 0.239137  │\n\n  sfmodel_fit(useData(mydf), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.verbose","page":"API Reference","title":"SFrontiers.verbose","text":"verbose(arg::Bool)\n\nAn argument in sfmodel_opt(). Specify whether to print on screen (true, the default) the information of the model and the optimization results.\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\nsfmodel_opt( verbose(false), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.warmstart_maxIT","page":"API Reference","title":"SFrontiers.warmstart_maxIT","text":"warmstart_maxIT(arg)\n\nAn argument in sfmodel_opt(). Specify the iteration limit for the warmstart. Default is 100.\n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\nsfmodel_opt( warmstart_maxIT(400), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.warmstart_solver","page":"API Reference","title":"SFrontiers.warmstart_solver","text":"warmstart_solver(arg)\n\nAn argument in sfmodel_opt(). Specify the algorithm used in the first-stage (\"warmstart\")   optimization process.\n\nThe default is NelderMead(). Others include SimulatedAnnealing(), SAMIN(), ParticleSwarm(),   ConjugateGradient(), GradientDescent(), BFGS(), LBFGS(),   Newton(), NewtonTrustRegion(), and IPNewton(). See   http://julianlsolvers.github.io/Optim.jl/stable/ for details.   Non-gradient based algorithms are recommended for the warmstart solver. \n\nSee the help on sfmodel_opt() for more information.\n\nExamples\n\nsfmodel_opt( warmstart_solver(NelderMead()), ...)\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.μ-Tuple","page":"API Reference","title":"SFrontiers.μ","text":"μ(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the name of the maxrix used as the data of the μ function.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> mumat\n100×2 Matrix{Float64}:\n -0.943133   1.0\n -0.897392   1.0\n  0.585447   1.0\n -0.46106    1.0\n -0.54563    1.0\n -0.619428   1.0\n  0.0575559  1.0\n  ⋮\n  0.0844192  1.0\n -1.3339     1.0\n  1.29332    1.0\n  0.691466   1.0\n  0.422962   1.0\n  0.374425   1.0\n\nsfmodel_spec(μ(mumat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.μ-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.μ","text":"μ(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for coefficients in the μ function.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init( μ(0.1, 0.2, 0.5), ...)\n\nb0 = ones(3)*0.1\nsfmodel_init( μ(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.σᵤ²-Tuple","page":"API Reference","title":"SFrontiers.σᵤ²","text":"σᵤ²(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the name of the maxrix used as the data of the σᵤ² function.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> zmat\n100×2 Matrix{Float64}:\n -0.943133   1.0\n -0.897392   1.0\n  0.585447   1.0\n -0.46106    1.0\n -0.54563    1.0\n -0.619428   1.0\n  0.0575559  1.0\n  ⋮\n  0.0844192  1.0\n -1.3339     1.0\n  1.29332    1.0\n  0.691466   1.0\n  0.422962   1.0\n  0.374425   1.0\n\nsfmodel_spec(σᵤ²(zmat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.σᵤ²-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.σᵤ²","text":"σᵤ²(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for coefficients in the σᵤ² function.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init( σᵤ²(0.1, 0.2, 0.5), ...)\n\nb0 = ones(3)*0.1\nsfmodel_init( σᵤ²(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.σᵥ²-Tuple","page":"API Reference","title":"SFrontiers.σᵥ²","text":"σᵥ²(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the name of the maxrix used as the data of the σᵥ² function.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> sigv2mat\n100×2 Matrix{Float64}:\n -0.943133   1.0\n -0.897392   1.0\n  0.585447   1.0\n -0.46106    1.0\n -0.54563    1.0\n -0.619428   1.0\n  0.0575559  1.0\n  ⋮\n  0.0844192  1.0\n -1.3339     1.0\n  1.29332    1.0\n  0.691466   1.0\n  0.422962   1.0\n  0.374425   1.0\n\nsfmodel_spec(σᵥ²(sigv2mat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.σᵥ²-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.σᵥ²","text":"σᵥ²(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for coefficients in the σᵥ² function.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init( σᵥ²(0.1, 0.2, 0.5), ...)\n\nb0 = ones(3)*0.1\nsfmodel_init( σᵥ²(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.σₐ²-Tuple","page":"API Reference","title":"SFrontiers.σₐ²","text":"σₐ²(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the name of the maxrix used as the data of the σₐ² function.\n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> amat\n100×2 Matrix{Float64}:\n -0.943133   1.0\n -0.897392   1.0\n  0.585447   1.0\n -0.46106    1.0\n -0.54563    1.0\n -0.619428   1.0\n  0.0575559  1.0\n  ⋮\n  0.0844192  1.0\n -1.3339     1.0\n  1.29332    1.0\n  0.691466   1.0\n  0.422962   1.0\n  0.374425   1.0\n\nsfmodel_spec(σₐ²(amat), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.σₐ²-Tuple{Vector{T} where T}","page":"API Reference","title":"SFrontiers.σₐ²","text":"σₐ²(arg::Vector)\n\nAn argument in sfmodel_init(). Specify the initial values for coefficients in the σₐ² function.\n\nSee the help on sfmodel_init() for more information.\n\nExamples\n\nsfmodel_init( σₐ²(0.1, 0.2, 0.5), ...)\n\nb0 = ones(3)*0.1\nsfmodel_init( σₐ²(b0), ...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#SFrontiers.@depvar-Tuple","page":"API Reference","title":"SFrontiers.@depvar","text":"@depvar(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the dependent variable using a column name from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec(@depvar(yvar), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@eq-Tuple{Any}","page":"API Reference","title":"SFrontiers.@eq","text":"@eq(arg)\n\nAn argument in sfmodel_predict(). Specify the name of the function to be predicted. \n\nSee the help on sfmodel_predict() for more information.\n\nExamples\n\nsfmodel_predict( @eq(frontier), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@frontier-Tuple","page":"API Reference","title":"SFrontiers.@frontier","text":"@frontier(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the variables in the frontier function using column names from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec(@frontier(xvar1, xvar2, _cons), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@gamma-Tuple","page":"API Reference","title":"SFrontiers.@gamma","text":"@gamma(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the variables in the gamma function using column names from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec( @gamma(zvar, _cons), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@hscale-Tuple","page":"API Reference","title":"SFrontiers.@hscale","text":"@hscale(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the variables in the hscale function using column names from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec( @hscale(zvar, _cons), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@idvar-Tuple","page":"API Reference","title":"SFrontiers.@idvar","text":"@idvar(arg::Vararg)\n\nAn argument in sfmodel_sepc() for panel data models. Specify the column name of a DataFrame that contain the individual's id information of the panel data. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×4 DataFrame\n│ Row │ year  │ firm  │ yvar  │ xvar1     │\n│     │ Int64 │ Int64 │ Int64 │ Float64   │\n├─────┼───────┼───────┼───────┼───────────┤\n│ 1   │ 2019  │ 1     │ 1     │ 0.77645   │\n│ 2   │ 2020  │ 1     │ 2     │ 0.0782388 │\n│ 3   │ 2021  │ 1     │ 3     │ 0.222884  │\n│ 4   │ 2022  │ 1     │ 4     │ 0.762864  │\n⋮\n│ 96  │ 2022  │ 24    │ 96    │ 0.590184  │\n│ 97  │ 2019  │ 25    │ 97    │ 0.364425  │\n│ 98  │ 2020  │ 25    │ 98    │ 0.639463  │\n│ 99  │ 2021  │ 25    │ 99    │ 0.500526  │\n│ 100 │ 2022  │ 25    │ 100   │ 0.239137  │\n\nsfmodel_spec( @idvar(firm), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@mu-Tuple","page":"API Reference","title":"SFrontiers.@mu","text":"@mu(arg::Vararg)\n\nalias of @μ. See help on @μ.\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@sigma_a_2-Tuple","page":"API Reference","title":"SFrontiers.@sigma_a_2","text":"@sigmaa2(arg::Vararg)\n\nalias of @σₐ². See help on @σₐ².\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@sigma_u_2-Tuple","page":"API Reference","title":"SFrontiers.@sigma_u_2","text":"@sigmau2(arg::Vararg)\n\nalias of @σᵤ². See help on @σᵤ².\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@sigma_v_2-Tuple","page":"API Reference","title":"SFrontiers.@sigma_v_2","text":"@sigmav2(arg::Vararg)\n\nalias of @σᵥ². See help on @σᵥ².\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@timevar-Tuple","page":"API Reference","title":"SFrontiers.@timevar","text":"@timevar(arg::Vararg)\n\nAn argument in sfmodel_sepc() for panel data models. Specify the column name of a DataFrame that contain the time information of the panel data. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×4 DataFrame\n│ Row │ year  │ firm  │ yvar  │ xvar1     │\n│     │ Int64 │ Int64 │ Int64 │ Float64   │\n├─────┼───────┼───────┼───────┼───────────┤\n│ 1   │ 2019  │ 1     │ 1     │ 0.77645   │\n│ 2   │ 2020  │ 1     │ 2     │ 0.0782388 │\n│ 3   │ 2021  │ 1     │ 3     │ 0.222884  │\n│ 4   │ 2022  │ 1     │ 4     │ 0.762864  │\n⋮\n│ 96  │ 2022  │ 24    │ 96    │ 0.590184  │\n│ 97  │ 2019  │ 25    │ 97    │ 0.364425  │\n│ 98  │ 2020  │ 25    │ 98    │ 0.639463  │\n│ 99  │ 2021  │ 25    │ 99    │ 0.500526  │\n│ 100 │ 2022  │ 25    │ 100   │ 0.239137  │\n\nsfmodel_spec( @timvar(year), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@μ-Tuple","page":"API Reference","title":"SFrontiers.@μ","text":"@μ(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the variables in the μ function using column names from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec( @μ(zvar, _cons), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@σᵤ²-Tuple","page":"API Reference","title":"SFrontiers.@σᵤ²","text":"@σᵤ²(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the variables in the σᵤ² function using column names from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec( @σᵤ²(zvar, _cons), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@σᵥ²-Tuple","page":"API Reference","title":"SFrontiers.@σᵥ²","text":"@σᵥ²(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the variables in the σᵥ² function using column names from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec( @σᵥ²(zvar, _cons), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.@σₐ²-Tuple","page":"API Reference","title":"SFrontiers.@σₐ²","text":"@σₐ²(arg::Vararg)\n\nAn argument in sfmodel_sepc(). Specify the variables in the σₐ² function using column names from a DataFrame. \n\nSee the help on sfmodel_spec() for more information.\n\nExamples\n\njulia> df\n100×5 DataFrame\n│ Row │ yvar  │ xvar1     │ xvar2     │ zvar      │ _cons   │\n│     │ Int64 │ Float64   │ Float64   │ Float64   │ Float64 │\n├─────┼───────┼───────────┼───────────┼───────────┼─────────┤\n│ 1   │ 1     │ 0.0306449 │ 0.452148  │ 0.808817  │ 1.0     │\n│ 2   │ 2     │ 0.460691  │ 0.296092  │ 0.454545  │ 1.0     │\n│ 3   │ 3     │ 0.897503  │ 0.376972  │ 0.907454  │ 1.0     │\n│ 4   │ 4     │ 0.682894  │ 0.776861  │ 0.161721  │ 1.0     │\n⋮\n│ 96  │ 96    │ 0.329647  │ 0.0914057 │ 0.825032  │ 1.0     │\n│ 97  │ 97    │ 0.0781165 │ 0.338999  │ 0.761652  │ 1.0     │\n│ 98  │ 98    │ 0.41394   │ 0.0063118 │ 0.295372  │ 1.0     │\n│ 99  │ 99    │ 0.516381  │ 0.285415  │ 1.91995   │ 1.0     │\n│ 100 │ 100   │ 0.944     │ 0.702226  │ -0.539848 │ 1.0     │\n\nsfmodel_spec( @σₐ²(_cons), ...)\n\n\n\n\n\n","category":"macro"},{"location":"api.html#SFrontiers.sfmodel_MixTable","page":"API Reference","title":"SFrontiers.sfmodel_MixTable","text":"sfmodel_MixTable(<keyword arguments>)\n\nDisplay and return critical values of the mixed χ² (ch-square) distribution. The values are taken from Table 1, Kodde and Palm (1986, Econometrica).\n\nArgument\n\ndof::Integer: the degree of freedom. Currently support dof between 1 and 40.\n\nExamples\n\njulia> sfmodel_MixTable(3)\n\n  * Significance levels and critical values of the mixed χ² distribution\n┌─────┬───────┬───────┬───────┬────────┐\n│ dof │  0.10 │  0.05 │ 0.025 │   0.01 │\n├─────┼───────┼───────┼───────┼────────┤\n│ 3.0 │ 5.528 │ 7.045 │ 8.542 │ 10.501 │\n└─────┴───────┴───────┴───────┴────────┘\n\nsource: Table 1, Kodde and Palm (1986, Econometrica).\n\n\n\n\n\n","category":"function"},{"location":"api.html#SFrontiers.sfmodel_predict-Tuple{Vector{Symbol}}","page":"API Reference","title":"SFrontiers.sfmodel_predict","text":"sfmodel_predict(@eq(eq_name), data::DataFrame)\n\nReturn predicted values of an equation (eq_name) of a stochastic frontier model specified and estimated by sfmodel_spec() and sfmodel_fit() .\n\nArguments:\n\n@eq(eq_name): where eq_name is the name of the equation to which the  value is to be predicted. A SF model has various equations, and different  SF models have different sets of equations. Eligible eq_names follow  those specified in sfmodel_spec(). The eq_name may be specified using  unicodes or their alias names; viz., @eq(σᵤ²) is the same as  @eq(sigma_u_2). Also, log_σᵤ² = log_sigma_u_2, σᵥ²= sigma_v_2,  log_σᵥ² = log_sigma_v_2, σₐ²= sigma_a_2, log_σₐ² = log_sigma_a_2,  and μ = mu.\ndata::DataFrame: the DataFrame used in sfmodel_fit(). The DataFrame is required only when Method 1 is used in specifying sfmodel_spec(). If Method 2 is used instead, do not need this argument. See the help of sfmodel_spec() for the information on Method 1 and Method 2.\n\nRemarks:\n\nThe predicted value is computed based on the equation's variable list and the estimated coefficient vector. For instance, if the frontier function is a linear function of variables X and coefficient vector β, sfmodel_predict(@eq(frontier), df) returns X*β̂. If the variance function σᵤ² is parameterized by an exponential function of Z and δ (i.e., σᵤ² = exp(Zδ)), sfmodel_predict(@eq(log_σᵤ²)) returns Z*δ̂ and sfmodel_predict(@eq(σᵤ²)) returns exp(Z*δ̂).\n\nExamples\n\nfrontier_hat = sfmodel_predict(@eq(frontier), df);\nsigma_u_2_hat = sfmodel_predict(@eq(σᵤ²), df);\n\n\n\n\n\n","category":"method"},{"location":"api.html#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"getting_started.html","page":"-","title":"-","text":"To get start, you first need to understand what is a stochastic frontier model.","category":"page"},{"location":"ex_cross.html#crosssectional","page":"cross-sectional models","title":"Examples of Cross-Sectional Stochastic Frontier Models","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"Pages = [\"ex_cross.md\"]\r\nDepth = 5","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"note: Reminder\nAs shown in the A Detailed Example section, SFrontiers estimates stochastic frontier models in four steps:model specification using sfmodel_spec(),\ninitial values using sfmodel_init() (optional),\nmaximization options (and others) using sfmodel_opt() (optional),\nestimation using sfmodel_fit().Here we only highlight the first step of using sfmodel_spec() for different models.","category":"page"},{"location":"ex_cross.html#Normal-Half-Normal","page":"cross-sectional models","title":"Normal Half-Normal","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"A general setup of the model is:","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"beginaligned\r\n  y_i  = x_i beta + epsilon_i\r\n  epsilon_i  = v_i - u_i\r\n  v_i sim N(0 sigma_v^2)   quad u_i  sim N^+(0 sigma_u^2)\r\nendaligned ","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"where","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"beginaligned\r\n  sigma_v^2  = exp(z_i^v rho)  quad  sigma_u^2  = exp(z_i^u gamma)\r\nendaligned","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"Here N^+(0 sigma_u^2) is a half-normal distribution obtained by truncating the normal distribution N(0 sigma_u^2) from below at 0. z_i^v and z_i^u are vectors of exogenous variables including a constant, and the two vectors need not be the same. If, for instance, z_i^v has only a constant, sigma_v^2 is a constant parameter.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"Both sigma_v^2 and sigma_u^2 are parameterized using exponential functions to ensure positive values. In the case of sigma_v^2, it is sigma_v^2 = exp(c_v), where c_v in R is an unconstrained constant, and the log-likelihood maximization is w.r.t. c_v (among others).","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"We continue the example of estimating the stochastic production frontier of Indian farmers. Some specifications may not make much economic sense, and they are used only for the sake of examples.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"using SFrontiers        # main packages\r\nusing DataFrames, CSV   # handling data\r\n\r\ndf = CSV.read(\"sampledata.csv\", DataFrame; header=1, delim=\",\")\r\ndf[!, :_cons] .= 1.0;         # append column _cons as a column of 1 ","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"This is the content of the data.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"julia> describe(df)\r\n11×8 DataFrame\r\n│ Row │ variable │ mean     │ min      │ median  │ max     │ nunique │ nmissing │ eltype   │\r\n│     │ Symbol   │ Float64  │ Real     │ Float64 │ Real    │ Nothing │ Nothing  │ DataType │\r\n├─────┼──────────┼──────────┼──────────┼─────────┼─────────┼─────────┼──────────┼──────────┤\r\n│ 1   │ yvar     │ 7.27812  │ 3.58666  │ 7.28586 │ 9.80335 │         │          │ Float64  │\r\n│ 2   │ Lland    │ 1.05695  │ -1.60944 │ 1.14307 │ 3.04309 │         │          │ Float64  │\r\n│ 3   │ PIland   │ 0.146997 │ 0.0      │ 0.0     │ 1.0     │         │          │ Float64  │\r\n│ 4   │ Llabor   │ 6.84951  │ 3.2581   │ 6.72263 │ 9.46622 │         │          │ Float64  │\r\n│ 5   │ Lbull    │ 5.64161  │ 2.07944  │ 5.68358 │ 8.37008 │         │          │ Float64  │\r\n│ 6   │ Lcost    │ 4.6033   │ 0.0      │ 5.1511  │ 8.73311 │         │          │ Float64  │\r\n│ 7   │ yr       │ 5.38007  │ 1        │ 5.0     │ 10      │         │          │ Int64    │\r\n│ 8   │ age      │ 53.8856  │ 26       │ 53.0    │ 90      │         │          │ Int64    │\r\n│ 9   │ school   │ 2.02583  │ 0        │ 0.0     │ 10      │         │          │ Int64    │\r\n│ 10  │ yr_1     │ 5.38007  │ 1        │ 5.0     │ 10      │         │          │ Int64    │\r\n│ 11  │ _cons    │ 1.0      │ 1        │ 1.0     │ 1       │         │          │ Int64    │","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#vanilla-[(Aigner,-Lovell,-and-Schmidt-1977)](@ref-literature)","page":"cross-sectional models","title":"vanilla (Aigner, Lovell, and Schmidt 1977)","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(half),\r\n             @depvar(yvar), \r\n             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons), \r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#with-inefficiency-determinants-[(Caudill-and-Ford-1993)](@ref-literature)","page":"cross-sectional models","title":"with inefficiency determinants (Caudill and Ford 1993)","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(half),\r\n             @depvar(yvar), \r\n             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons), \r\n             @σᵤ²(age, school, yr, _cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#with-inefficiency-determinants-and-production-uncertainty","page":"cross-sectional models","title":"with inefficiency determinants and production uncertainty","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"The sigma_v^2 is sometimes interpreted as production uncertainty (Bera and Sharma 1999). We show that the uncertainty can be parameterized by exogenous variables in the model. Here we assume that the uncertainty may be influenced by year (yr) effect (changes in the weather condition, etc.).","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(half),\r\n             @depvar(yvar), \r\n             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons), \r\n             @σᵤ²(age, school, _cons),\r\n             @σᵥ²(yr, _cons))","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#Normal-Truncated-Normal","page":"cross-sectional models","title":"Normal Truncated-Normal","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"The setup is the same as in the A Detailed Example section. We repeated it here for clarity.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"beginaligned\r\n y_i  = x_i beta + epsilon_i\r\n epsilon_i  = v_i - u_i\r\n v_i sim N(0 sigma_v^2) quad  u_i  sim N^+(mu sigma_u^2) \r\nendaligned","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"where","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"beginaligned\r\n  sigma_v^2  =  exp(z_i^v rho)\r\n  mu  = z_i^m delta  quad  sigma_u^2  = exp(z_i^u gamma)\r\nendaligned","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"Again, z_i^v, z_i^m, z_i^u could be a vector of variables or a single constant variable.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#vanilla-[(Stevenson-1980)](@ref-literature)","page":"cross-sectional models","title":"vanilla (Stevenson 1980)","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(trun),\r\n             @depvar(yvar), \r\n             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons), \r\n             @mu(_cons),\r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#inefficiency-determinants-in-\\mu-[(Kumbhakar,-Ghosh,-and-McGuckin,-1991;-Huang-and-Liu,-1994;-Battese-and-Coelli,-1995)](@ref-literature)","page":"cross-sectional models","title":"inefficiency determinants in mu (Kumbhakar, Ghosh, and McGuckin, 1991; Huang and Liu, 1994; Battese and Coelli, 1995)","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(trun),\r\n             @depvar(yvar), \r\n             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons), \r\n             @mu(age, school, _cons),\r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#inefficiency-determinants-in-\\mu-and-\\sigma_u2,-*aka*-the-non-monotonic-effecct-model-([Wang-2002](@ref-literature))","page":"cross-sectional models","title":"inefficiency determinants in mu and sigma_u^2, aka the non-monotonic effecct model (Wang 2002)","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"We show details of this model in the section A Detailed Example.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(trun),\r\n             @depvar(yvar), \r\n             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons), \r\n             @mu(age, school, _cons),\r\n             @σᵤ²(age, school, _cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#Normal-Truncated-Normal-with-the-Scaling-Property","page":"cross-sectional models","title":"Normal Truncated-Normal with the Scaling Property","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"beginaligned\r\n y_i  = x_i beta + epsilon_i\r\n epsilon_i  = v_i - u_i\r\n v_i sim N(0 sigma_v^2) quad  u_i sim h(z_i^h delta) N^+(mu sigma_u^2)\r\nendaligned","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"where","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"beginaligned\r\n  sigma_v^2  =  exp(z_i^v rho)  \r\n h(z_i^h delta) =  exp(z_i^h delta)  quad   sigma_u^2  = exp(c_u)\r\n endaligned","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"Both of the mu and sigma_u^2 are constant parameters in this model, and thus z_i^h cannot contain a constant for the identification purpose.  The h(cdot) is a non-negative function, and we assume an exponential function with linear z_i^h in this model.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#the-specification-([Wang-and-Schmidt-2002,-Alvarez,-Amsler,-and-Schmidt-2006](@ref-literature))","page":"cross-sectional models","title":"the specification (Wang and Schmidt 2002, Alvarez, Amsler, and Schmidt 2006)","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(trun_scale), \r\n             @depvar(ly), \r\n             @frontier(llabor, lfeed, lcattle, lland, _cons), \r\n             @hscale(comp),       # cannot contain a constant\r\n             @μ(_cons),\r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"\n","category":"page"},{"location":"ex_cross.html#Normal-Exponential","page":"cross-sectional models","title":"Normal Exponential","text":"","category":"section"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"This model assumes u_i follows an exponential distribution. ","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"beginaligned\r\nu_i  sim mathrmExp(sigma_u^2)\r\nendaligned ","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"where sigma_u^2 is the scale parameter such that E(u_i) = sigma_u and Var(u_i) = sigma_u^2. The sigma_u^2 may be parameterized by a vector of variables, as we show in the following example.","category":"page"},{"location":"ex_cross.html","page":"cross-sectional models","title":"cross-sectional models","text":"sfmodel_spec(sftype(prod), sfdist(expo),\r\n             @depvar(ly), \r\n             @frontier(llabor, lfeed, lcattle, lland, _cons), \r\n             @σᵤ²(comp, _cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"overview.html#Estimation-Overview","page":"Estimation Overview","title":"Estimation Overview","text":"","category":"section"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"Consider a typical stochastic frontier model,","category":"page"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"  beginaligned\r\n   y_i = f(x_i beta) + v_i - u_i(z_i)\r\n  endaligned","category":"page"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"where v_i and u_i(z_i) 0 are both stochastic. ","category":"page"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"SFrontiers provides utilities to estimate the model using the maximum likelihood approach.","category":"page"},{"location":"overview.html#.-Specify-the-model-using-sfmodel_spec()","page":"Estimation Overview","title":"1. Specify the model using sfmodel_spec()","text":"","category":"section"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"a cross-sectional (the default) or a panel data (require tags) model\na production or a cost  type of model\ndistribution assumptions on u_i\nnames of variables for y_i, x_i, and z_i (if any)","category":"page"},{"location":"overview.html#.-(optional)-Provide-initial-values-using-sfmodel_init()","page":"Estimation Overview","title":"2. (optional) Provide initial values using sfmodel_init()","text":"","category":"section"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"initial values for the maximum likelihood estimation\na full list or a partial list for some of the equations","category":"page"},{"location":"overview.html#.-(optional)-Provide-parameters-for-numerical-maximization-and-other-controls-using-sfmodel_opt()","page":"Estimation Overview","title":"3. (optional) Provide parameters for numerical maximization and other controls using sfmodel_opt()","text":"","category":"section"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"algorithms (e.g., Nelder-Mead, BFGS, Newton, etc.)\nmaximum iteration number\nconvergence criterion\ninformation to print on screen\nwhether calculating inefficiency index, marginal effect, etc.","category":"page"},{"location":"overview.html#.-Start-the-Numerical-Maximization-Process-using-sfmodel_fit()","page":"Estimation Overview","title":"4. Start the Numerical Maximization Process using sfmodel_fit()","text":"","category":"section"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"name of the dataset","category":"page"},{"location":"overview.html#.-Conduct-Post-Estimation-Analysis","page":"Estimation Overview","title":"5. Conduct Post-Estimation Analysis","text":"","category":"section"},{"location":"overview.html","page":"Estimation Overview","title":"Estimation Overview","text":"hypothesis testing \nthe inefficiency index of Jondrow et al. (1982) or the efficiency index of Battese and Coelli (1988)\nmarginal effect of the inefficiency determinants","category":"page"},{"location":"LICENSE.html","page":"License","title":"License","text":"MIT License","category":"page"},{"location":"LICENSE.html","page":"License","title":"License","text":"Copyright (c) 2021 Hung-Jen Wang","category":"page"},{"location":"LICENSE.html","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"LICENSE.html","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"LICENSE.html","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"note: Jupyter Notebook\nThis example and the associated data is also available as a Jupyter notebook for download.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We use an example to go through the specification and estimation process of using SFrontiers in a stochastic frontier (SF) analysis. The example is a cross-sectional stochastic production frontier model with the normal and truncated-normal distribution assumptions. In addition, exogenous determinants are included in the model in the style of Wang (2002). We choose this elaborated model to showcase the features of SFrontiers.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Pages = [\"ex_detail.md\"]\r\nDepth = 4","category":"page"},{"location":"ex_detail.html#detailedexample","page":"A Detailed Example","title":"Model Setup","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Consider the following setup:","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":" mathbfy  =  mathbfx beta + mathbfv - mathbfu","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"where mathbfy is (Ntimes 1), mathbfx is (Ntimes k) and includes a column of 1 for intercept, and beta is (k times 1). mathbfv and mathbfu are from random variables assumed to follow certain distribution assumptions. ","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We use x_i (which is (1 times k)) to denote the ith observation of mathbfx. Other notations follow similarly. The specification of the Wang (2002) model is thus:","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"beginaligned\r\n y_i  = x_i beta + epsilon_i\r\n epsilon_i  = v_i - u_i\r\n v_i  sim N(0 sigma_v^2)\r\n u_i  sim N^+(mu sigma_u^2)\r\n mu  = z_i delta quad mathrmand quad sigma_u^2  = exp(z_i gamma)\r\n endaligned","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Here, N^+(mu sigma_u^2) denotes a truncated normal distribution obtained by truncating the normal distribution N(mu sigma_u^2) from below at 0. The mu and sigma_u^2 are thus the mean and the variance of the normal distribution before the truncation. z_i is a vector of exogenous determinants of inefficiency. Wang (2002) parameterizes both mu and sigma_u^2 by the same vector of z_i while Battese and Coelli (1995) only parameterize mu.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Note that the variance parameters sigma_v^2 and sigma_u^2 are parameterized using exponential functions to ensure positive values. In the case of sigma_v^2,","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"  sigma_v^2 = exp(c_v)","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"where c_v in R is an unconstrained constant, and the log-likelihood maximization is w.r.t. c_v (among others).","category":"page"},{"location":"ex_detail.html#goal-of-estimation","page":"A Detailed Example","title":"goal of estimation","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Our goals of the model estimation include:","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"estimate model parameters beta delta gamma sigma_v^2  ,\ncompute the inefficiency index Eu_i  epsilon_i_epsilon_i =hatepsilon_i and the efficiency index Eexp(-u_i)  epsilon_i_epsilon_i =hatepsilon_i at the observation level,\ncalculate the marginal effect of z_i on E(u_i).","category":"page"},{"location":"ex_detail.html#:-Giving-Model-Specification-using-sfmodel_spec()","page":"A Detailed Example","title":"1: Giving Model Specification using sfmodel_spec()","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We use the production data from paddy farmers in India as an empirical example. The mathbfy is the annual rice production and mathbfx is a vector of agricultural inputs. ","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"There are two ways to provide data to Sfmodel for estimation. One is to use data from a DataFrame where column names of the data are variable names. The other is to use data from matrices or vectors. The latter is the likely scenario in simulation studies where we generate data matrices and feed them to the model. Different ways of providing data would require slightly different specifications of sfmodel_spec(). ","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Since the farmers data is formatted, it is natural to use the DataFrame approach. We will show the matrix approach later.","category":"page"},{"location":"ex_detail.html#useDataFrame","page":"A Detailed Example","title":"using DataFrame data","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Our farmers dataset is in the .csv format, and we read it in using the CSV package and save it as a DataFrame with the name df.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> using SFrontiers        # main packages\r\njulia> using DataFrames, CSV   # handling data\r\n\r\njulia> df = CSV.read(\"sampledata.csv\", DataFrame; header=1, delim=\",\");\r\njulia> df[!, :_cons] .= 1.0;         # append column _cons as a column of 1 ","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We append a column of 1 to df with the column name _cons. Adding this constant variable to the dataset is essential because we will use it to estimate constant parameters; more on this later. Before estimation, users should ensure that the data in df has been cleaned, i.e., it contains no missing values or any anomaly that may affect the estimation.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Let's see what is in the data.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> describe(df)   # summary statistics\r\n11×7 DataFrame\r\n Row │ variable  mean       min       median    max       nmissing  eltype   \r\n     │ Symbol    Float64    Real      Float64   Real      Int64     DataType \r\n─────┼───────────────────────────────────────────────────────────────────────\r\n   1 │ yvar       7.27812    3.58666   7.28586   9.80335         0  Float64  \r\n   2 │ Lland      1.05695   -1.60944   1.14307   3.04309         0  Float64\r\n   3 │ PIland     0.146997   0.0       0.0       1.0             0  Float64\r\n   4 │ Llabor     6.84951    3.2581    6.72263   9.46622         0  Float64\r\n   5 │ Lbull      5.64161    2.07944   5.68358   8.37008         0  Float64\r\n   6 │ Lcost      4.6033     0.0       5.1511    8.73311         0  Float64\r\n   7 │ yr         5.38007    1         5.0      10               0  Int64\r\n   8 │ age       53.8856    26        53.0      90               0  Int64\r\n   9 │ school     2.02583    0         0.0      10               0  Int64\r\n  10 │ yr_1       5.38007    1         5.0      10               0  Int64\r\n  11 │ _cons      1.0        1         1.0       1               0  Int64","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Now we give model information to SFrontiers using sfmodel_spec(). Before we start: I take advantage of Julia's support of unicode characters and use a few math symbols in SFrontiers functions. They are not difficult to use, and they help to match codes to models in papers thus making the code easier to understand. Nevertheless, I provide ascii alias of those symbols that can be used as alternatives.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"This function generates a (global) dictionary that is automatically remembered and used in subsequent commands. The following specification indicates a Wang (2002) type of model, i.e., one that has a truncated normal distribution on u_i and both mu and sigma_u^2 are parameterized by a vector of variables.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> sfmodel_spec(sftype(prod), sfdist(trun),\r\n                    @depvar(yvar),\r\n                    @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons),\r\n                    @μ(age, school, yr, _cons),\r\n                    @σᵤ²(age, school, yr, _cons),\r\n                    @σᵥ²(_cons), message = true);","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"sftype(prod) indicates a production-frontier type of model. The alternative is cost for cost frontier where the composed error is v_i + u_i.\nsfdist(trun) specifies the truncated-normal distribution assumption on u_i. Alternatives include half, expo, and trun_scaling.\n@depvar(.) specifies the dependent variable.\n@frontier(.) specifies the list of variables used in the frontier equation (i.e., the data of mathbfx). The variables are assumed to be linear in the equation.\n@μ(.) (or @mu(.)) specifies the variables of inefficiency determinants as a linear function in μ.\n@σᵤ²(.) (or @sigma_u_2(.)) and @σᵥ²(.) (or @sigma_v_2(.)) specify the variables to parameterize the variances. Here we include only the variable _cons in sigma_v^2 so it is estimated as a constant.\nmessage determines whether to print the confirmation message of \"A dictionary from ...\". The default is false.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Note how the constant parameter sigma_v^2 is estimated. Recall the programming trick of using sigma_v^2 = exp(c_v) in the likelihood function. Here, c_v is simply the coefficient of the _cons variable. ","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"tip: Note on intercepts and constant parameters\nSFrontiers estimates intercepts and constant parameters as the coefficients of a constant variable. That is, if a parameter is constant, SFrontiers requires a variable with values equal to 1. It is true for all equations. ","category":"page"},{"location":"ex_detail.html#matrixinput","page":"A Detailed Example","title":"using matrix data (alternative data input)","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"As aforementioned, data for estimation could also come from matrix and vectors, though the syntax of sfmodel_spec() is slightly different. The following code snippet has a simple example where we generate data in matrix for a normal half-normal model, and use them in sfmodel_spec(). The number of observations is 300.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"using SFrontiers, Random, Distributions\r\n\r\ncons, x, v = ones(300,1), [randn(300, 2) ones(300,1)], randn(300,1)    \r\n\r\ndisTN = TruncatedNormal(0.0, 1.0, 0.0, Inf)    # half-normal dist with std dev = 1\r\nu = rand(disTN, (300,1))                       # draw from half-normal r.v. \r\n\r\ny = x*ones(3)*0.5 .+ v .- u\r\n\r\nsfmodel_spec(sftype(prod),  sfdist(half),   \r\n            depvar(y),  frontier(x),  σᵤ²(cons),  σᵥ²(cons))","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Note that the only difference in the syntax is using the function type of equation names (e.g., depvar()) instead of the macro type names (e.g., @depvar()). The rest of the estimation procedures are the same.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"tip: Note on `@depvar( )` vs. `depvar( )`\nMacro type of equation names (@depvar(), @frontier(), @μ(), etc.) are used only when the arguments are column names from DataFrames. For everything else, function type of equation names (depvar(), frontier(), μ(), etc.) are used.","category":"page"},{"location":"ex_detail.html#:-Providing-Initial-Values-using-sfmodel_init()-*(optional)*","page":"A Detailed Example","title":"2: Providing Initial Values using sfmodel_init() (optional)","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Providing initial values is helpful in many cases though it is optional. You could skip it entirely or provide initial values only to a partial list of the equations. If missing (all or part of the equations), default values will be used. Currently, the default uses the OLS estimates as initial values for coefficients in frontier() and 01 for all other parameters. Here we use a mixed strategy in this example.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> b_ini = ones(4)*(0.1)                      # a 4x1 vector of 0.1\r\n\r\njulia> sfmodel_init(  # frontier(bb),             # skip and use default\r\n                    μ(b_ini),                     # as a vector\r\n                    σᵤ²(-0.1, -0.1, -0.1, -0.1),  # manually input the vector\r\n                    σᵥ²(-0.1) )                   # scalar","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"The order of equations in sfmodel_init() is not important. You can put μ() before or after σᵥ²(), it does not matter.\nThe function type of equation names (e.g., frontier(), μ(), etc.) are used in sfmodel_init().\nInitial values specified in σᵥ²() is w.r.t. the c_v as in sigma_v^2 = exp(c_v). Put differently, the initial value is w.r.t. log(sigma_v^2). If we put σᵥ²(-0.1), it means we have in mind the initial value of sigma_v^2 being exp(-01) = 0905.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"tip: Note on name conflict\nSFrontiers uses names such as μ, σᵥ², gamma, depvar, frontier, etc.. If the names were used elsewhere in the program for different purposes (for instance, using μ to denote the value of a parameter), or users import other packages that use the same names, the name conflicts would arise. Signs of the problem include error messages such as MethodError: objects of type ... are not callableThere are simple ways to workaround:Use fully qualified names. For instance, use SFrontiers.σᵥ² instead of σᵥ².\nUse an alias if there is one. For instance, use sigma_v_2 instead of σᵥ². Check out the section of API Reference for more information.","category":"page"},{"location":"ex_detail.html#:-Choosing-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*","page":"A Detailed Example","title":"3: Choosing Maximization Options (and others) using sfmodel_opt() (optional)","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"The main purpose of this function is to choose options for the numerical maximization process, including the choice of optimization algorithms, the maximum number of iterations, the convergence criterion, and others. SFrontiers uses Julia's Optim package to do the maximization, though only a subset of Optim's options are directly accessible through sfmodel_opt().","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"An effective estimation strategy for challenging optimization problems is to use a non-gradient algorithm in the first stage (warmstart) for a few iterations and then switch to gradient-based algorithms in the second stage (main) for speed and accuracy. SFrontiers uses the two-step strategy by default.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"This function is also optional. All or part of the specifications may be skipped. If missing, default values will be used. The following example uses the default values.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> sfmodel_opt(warmstart_solver(NelderMead()),   \r\n                   warmstart_maxIT(400),\r\n                   main_solver(Newton()), \r\n                   main_maxIT(2000), \r\n                   tolerance(1e-8))","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"warmstart_solver(NelderMead()): specifies the Nelder-Mead algorithm (which is gradient-free) in the first stage estimation. Mind the braces \"()\" which is part of the algorithm name. Using a non-gradient algorithm in the first stage is recommended.\nmain_solver(Newton()): specifies the Newton method (which uses 2nd derivatives, i.e., Hessian) in the second stage estimation. \nwarmstart_maxIT(400) and main_maxIT(2000): the maximum numbers of iterations in the first and the second stage estimation.\ntolerance(1e-8): set the convergence criterion concerning the absolute tolerance in the gradient to 1e-8. For non-gradient algorithms, it controls the main convergence tolerance, which is solver-specific. This is a wrapper of Optim's g_tol option.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"If the two-stage strategy is not desired, we can skip the warmstart stage by giving empty keyword values to the first stage options, such as warmstart_solver() or warmstart_maxIT(), or both. Note that if we skip the keywords (i.e., missing warmstart_solver or warmstart_maxIT entirely), the default will be reinstated. Again, the first stage estimation will only be skipped when empty values are explicitly given to the related options.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"In addition to controlling the maximization procedures, sfmodel_opt() also provides options to control other things. They and their default values are the follows. ","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"table_format(text): specify the format to print coefficient tables on the screen after sfmodel_fit() is run. The choices include text, html (good for web-based notebooks such as Jupyter, Pluto), and latex.\nbanner(true): show banner to help visually identify the start of the estimation. \nverbose(true): show interim and final results.\nineff_index(true): compute the Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1987) efficiency index.\nmarginal(true): calculate the marginal effect of the inefficiency determinants (if any) on the unconditional mean of inefficiency.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Turning the above options to false may sometimes be desirable, particularly in simulation settings.","category":"page"},{"location":"ex_detail.html#:-Starting-Model-Maximization-using-sfmodel_fit()","page":"A Detailed Example","title":"4: Starting Model Maximization using sfmodel_fit()","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Previous steps prepare the model, and now we are ready to estimate it. We use sfmodel_fit() to start the estimation, and it returns a dictionary containing coefficient estimates, efficiency and inefficiency index, marginal effects of inefficiency determinants, and other information of the model. In the following example, we save the returned dictionary in res.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> res = sfmodel_fit(useData(df))  # df is the DataFrame","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"useData(df): name of the DataFrame used in the 1st step.\nIf the estimation data is from matrix and vectors, the useData() option should be omitted. That is, we would do res = sfmodel_fit().","category":"page"},{"location":"ex_detail.html#:-Results-and-Post-Estimation-Analysis","page":"A Detailed Example","title":"5: Results and Post Estimation Analysis","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Main results of the estimation will be shown on the screen after it is done. Let's see what we have.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"*********************************\r\n       Estimation Results:\r\n*********************************\r\nModel type: the non-monotonic model of Wang (2002, JPA), normal and truncated-normal\r\nNumber of observations: 271\r\nNumber of total iterations: 153\r\nConverged successfully: true\r\nLog-likelihood value: -82.02573\r\n\r\n┌──────────┬────────┬─────────┬──────────┬──────────┬────────┬─────────┬─────────┐\r\n│          │   Var. │   Coef. │ Std.Err. │        z │  P>|z| │ 95%CI_l │ 95%CI_u │\r\n├──────────┼────────┼─────────┼──────────┼──────────┼────────┼─────────┼─────────┤\r\n│ frontier │  Lland │  0.2582 │   0.0725 │   3.5607 │ 0.0004 │  0.1161 │  0.4003 │\r\n│          │ PIland │  0.1717 │   0.1761 │   0.9751 │ 0.3304 │ -0.1734 │  0.5169 │\r\n│          │ Llabor │  1.1658 │   0.0840 │  13.8805 │ 0.0000 │  1.0012 │  1.3304 │\r\n│          │  Lbull │ -0.4215 │   0.0596 │  -7.0668 │ 0.0000 │ -0.5384 │ -0.3046 │\r\n│          │  Lcost │  0.0142 │   0.0128 │   1.1087 │ 0.2686 │ -0.0109 │  0.0394 │\r\n│          │     yr │  0.0183 │   0.0095 │   1.9227 │ 0.0556 │ -0.0004 │  0.0369 │\r\n│          │  _cons │  1.5429 │   0.3578 │   4.3123 │ 0.0000 │  0.8417 │  2.2442 │\r\n│        μ │    age │ -0.0479 │   0.0303 │  -1.5804 │ 0.1153 │ -0.1073 │  0.0115 │\r\n│          │ school │ -0.2143 │   0.1711 │  -1.2523 │ 0.2116 │ -0.5497 │  0.1211 │\r\n│          │     yr │  0.1480 │   0.1248 │   1.1853 │ 0.2370 │ -0.0967 │  0.3926 │\r\n│          │  _cons │  1.0418 │   0.7283 │   1.4305 │ 0.1538 │ -0.3856 │  2.4693 │\r\n│  log_σᵤ² │    age │  0.0256 │   0.0096 │   2.6660 │ 0.0082 │  0.0068 │  0.0445 │\r\n│          │ school │  0.1141 │   0.0569 │   2.0055 │ 0.0460 │  0.0026 │  0.2256 │\r\n│          │     yr │ -0.2256 │   0.0496 │  -4.5507 │ 0.0000 │ -0.3228 │ -0.1284 │\r\n│          │  _cons │ -1.1399 │   0.8904 │  -1.2803 │ 0.2016 │ -2.8850 │  0.6052 │\r\n│  log_σᵥ² │  _cons │ -3.2667 │   0.2623 │ -12.4556 │ 0.0000 │ -3.7808 │ -2.7527 │\r\n└──────────┴────────┴─────────┴──────────┴──────────┴────────┴─────────┴─────────┘\r\n\r\nConvert the constant log-parameter to its original scale, e.g., σ² = exp(log_σ²):\r\n┌─────┬────────┬──────────┐\r\n│     │  Coef. │ Std.Err. │\r\n├─────┼────────┼──────────┤\r\n│ σᵥ² │ 0.0381 │   0.0100 │\r\n└─────┴────────┴──────────┘\r\n\r\nTable format: text. Use sfmodel_opt() to choose between text, html, and latex.\r\n\r\n***** Additional Information *********\r\n* OLS (frontier-only) log-likelihood: -104.96993\r\n* Skewness of OLS residuals: -0.70351\r\n* The sample mean of the JLMS inefficiency index: 0.33416\r\n* The sample mean of the BC efficiency index: 0.7462\r\n\r\n* The sample mean of inefficiency determinants' marginal effects on E(u): (age = -0.00264, school = -0.01197, yr = -0.0265)\r\n* Marginal effects of the inefficiency determinants at the observational level are saved in the return. See the follows.\r\n\r\n* Use `name.list` to see saved results (keys and values) where `name` is the return specified in `name = sfmodel_fit(..)`. Values may be retrieved using the keys. For instance:\r\n   ** `name.loglikelihood`: the log-likelihood value of the model;\r\n   ** `name.jlms`: Jondrow et al. (1982) inefficiency index;\r\n   ** `name.bc`: Battese and Coelli (1988) efficiency index;\r\n   ** `name.marginal`: a DataFrame with variables' (if any) marginal effects on E(u).\r\n* Use `keys(name)` to see available keys.\r\n**************************************","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"As reminded in the printout, all of the shown statistics and many of the other model information are saved in the dictionary which can be called later for further investigation. We have saved it in res. Let's see the list of available keys.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> keys(res)      # keywords in res\r\n(:converged, :iter_limit_reached, :_______________, :n_observations, :loglikelihood, :table, :coeff, :std_err, :var_cov_mat, :jlms, :bc, :OLS_loglikelihood, :OLS_resid_skew, :marginal, :marginal_mean, :_____________, :model, :depvar, :frontier, :μ, :σₐ², :σᵤ², :σᵥ², :log_σₐ², :log_σᵤ², :log_σᵥ², :type, :dist, :PorC, :timevar, :idvar, :table_format, :modelid, :verbose, :hasDF, :transfer, :coeff_frontier, :coeff_μ, :coeff_log_σᵤ², :coeff_log_σᵥ², :________________, :Hessian, :gradient_norm, :actual_iterations, :______________, :warmstart_solver, :warmstart_ini, :warmstart_maxIT, :main_solver, :main_ini, :main_maxIT, :tolerance, :eqpo, :redflag, :list)","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Among the keywords is the term :coeff, which indicates the saved coefficient vector. We may retrieve the coefficient vector using res.coeff and save it in the name b0 possibly for later use.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> b0 = res.coeff\r\n16-element Vector{Float64}:\r\n  0.25821563731697006\r\n  0.17173767708354643\r\n  1.1658044162884234\r\n -0.42146760552733187\r\n  0.01423909223722116\r\n  0.018252219999852187\r\n  1.5429396143493048\r\n -0.04790078227380377\r\n -0.21428860376262238\r\n  0.14796117144545648\r\n  1.0418278985865976\r\n  0.02563602493190338\r\n  0.11408617664438392\r\n -0.22559216646964741\r\n -1.1399135714873936\r\n -3.2667147597612805","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"The estimation table shown above with the coefficients, standard errors, etc., may also be retrieved using the keyword table (e.g., res.table), though it may not be formatted as pretty.","category":"page"},{"location":"ex_detail.html#.1-hypothesis-testing","page":"A Detailed Example","title":"5.1 hypothesis testing","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We may conduct a likelihood ratio (LR) test to see if the data support the frontier specification. The null hypothesis is that the inefficiency term u_i is not warranted, and the model's fit is no better than the OLS.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"First, we calculate the test statistics using the log-likelihood values of the OLS model (keyword OLS_loglikelihood) and the current model (keyword loglikelihood).","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> -2*(res.OLS_loglikelihood - res.loglikelihood)  # statistic of the LR test\r\n45.88840046714324","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Because the test amounts to testing u_i =0 which is on the boundary of the parameter's support, the appropriate distribution for the test statistic is the mixed chi^2 distribution. Critical values may be retrieved using sfmodel_MixTable(dof) where dof is the degree of freedom of the test. In this example, dof=8 because there are five parameters involved in u_i.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> sfmodel_MixTable(8)   # critical values of the mixed chi^2 test\r\n\r\n  * Significance levels and critical values of the mixed χ² distribution\r\n┌─────┬────────┬────────┬────────┬────────┐\r\n│ dof │   0.10 │   0.05 │  0.025 │   0.01 │\r\n├─────┼────────┼────────┼────────┼────────┤\r\n│ 8.0 │ 12.737 │ 14.853 │ 16.856 │ 19.384 │\r\n└─────┴────────┴────────┴────────┴────────┘\r\n\r\nsource: Table 1, Kodde and Palm (1986, Econometrica).","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Since the test statistic 45888 is much larger than the critical value at the 1 level (which is 19384), the test overwhelmingly rejects the null hypothesis of an OLS model.","category":"page"},{"location":"ex_detail.html#.2-inefficiency-and-efficiency-index","page":"A Detailed Example","title":"5.2 inefficiency and efficiency index","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"The Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1987) efficiency index at the observation level may also be retrieved using the keywords jlms and bc. Here we show them in a Ntimes 2 matrix.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia>  [res.jlms  res.bc]   # efficiency and inefficiency index\r\n271×2 Matrix{Float64}:\r\n 0.571113  0.574409\r\n 0.510028  0.6102\r\n 0.103925  0.904532\r\n 0.287701  0.758799\r\n 0.151947  0.864143\r\n 0.570984  0.574327\r\n ⋮\r\n 1.17586   0.314258\r\n 0.428381  0.662442\r\n 0.847952  0.436286\r\n 0.110013  0.899444\r\n 0.175163  0.845745\r\n 0.165558  0.853443","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Let's do some graphical presentation on the index using the Plots package. (You may have to add the package by ] add Plots.) The following code plots histograms of the index.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> using Plots   # if not installed: `using Pkg; Pkg.add(\"Plots\"); using Plots`\r\n\r\njulia> h1 = histogram(res.jlms, xlabel=\"JLMS\", bins=100, label=false)\r\njulia> h2 = histogram(res.bc, xlabel=\"BC\", bins=50, label=false)\r\njulia> h1h2= plot(h1, h2, layout = (1,2), legend=false)","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"(Image: histogram)","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We may save the above figure to the disk for later use. Here we save it in the .svg format as histPlot.svg.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> savefig(h1h2, \"histPlot.svg\")  # or .png, .pdf","category":"page"},{"location":"ex_detail.html#.3-marginal-effects","page":"A Detailed Example","title":"5.3 marginal effects","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Let's use the keyword marginal to see the marginal effects of the inefficient determinants on E(u) at the observational level, which are saved in the returned dictionary as a DataFrame object.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> res.marginal  # marginal effects of inefficiency determinants\r\n271×3 DataFrame\r\n│ Row │ marg_age    │ marg_school │ marg_yr     │\r\n│     │ Float64     │ Float64     │ Float64     │\r\n├─────┼─────────────┼─────────────┼─────────────┤\r\n│ 1   │ -0.00522016 │ -0.023474   │ -0.0134693  │\r\n│ 2   │ -0.00636249 │ -0.0285745  │ -0.00756082 │\r\n│ 3   │ -0.00775711 │ -0.0348048  │ -0.00112862 │\r\n│ 4   │ -0.00953811 │ -0.0427643  │ 0.00631516  │\r\n⋮\r\n│ 267 │ 0.00211669  │ 0.00933601  │ -0.0390966  │\r\n│ 268 │ 0.00291555  │ 0.0128358   │ -0.0596532  │\r\n│ 269 │ 0.00221362  │ 0.00971877  │ -0.0518262  │\r\n│ 270 │ 0.00160347  │ 0.00700978  │ -0.0449159  │\r\n│ 271 │ 0.00107273  │ 0.00465371  │ -0.0388223  │","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We may also plot the marginal effect.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> m1 = plot(df[:,:age], res.marginal[:,:marg_age], seriestype = :scatter, xlabel = \"age\", \r\n                 ylabel = \"marginal effect of age in E(u)\", label = false)\r\njulia> hline!([0.00], label = false)","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"(Image: marginaleffect)","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"The plot indicates that production inefficiency decreased (efficiency improved) with age in the early years of the farmer’s life, perhaps because of experience accumulation. But the inefficiency increased with age in later years, perhaps due to deteriorated mental and physical health. Wang's (2002) model allows the non-monotonic effect to show in the data by parameterizing both of mu and sigma_u^2 by the same vector of inefficiency determinants.","category":"page"},{"location":"ex_detail.html#.4-bootstrapping-standard-errors-and-obtaining-confidence-intervals-of-the-mean-marginal-effects","page":"A Detailed Example","title":"5.4 bootstrapping standard errors and obtaining confidence intervals of the mean marginal effects","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"sfmodel_fit() calculates the means of the marginal effects and the values are reported in the printout: * The sample mean of inefficiency determinants' marginal effects on E(u): (age = -0.00264, school = -0.01197, yr = -0.0265). We may bootstrap the standard errors and obtain confidence intervals of the mean marginal effects using sfmodel_boot_marginal(). As a demonstration, in this example we use only 100 bootstrapped samples (R=100) and restrict the iteration number to 100 (iter=100). We also save the bootstrapped data by specifying the option getBootData=true and catching it in bsdata from the second return of the function. The data would be R times K where K=3 in this example.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> err_ci, bsdata = sfmodel_boot_marginal(result=res, data=df, R=100, seed=1232, iter=100, getBootData=true);\r\n\r\nbootstrap in progress..10..20..30..40..50..60..70..80..90..100..Done!\r\n\r\n┌────────┬──────────────────────┬─────────────────┬──────────────────────┐\r\n│        │ mean of the marginal │ std.err. of the │       bias-corrected │\r\n│        │       effect on E(u) │     mean effect │    95.0%  conf. int. │\r\n├────────┼──────────────────────┼─────────────────┼──────────────────────┤\r\n│    age │             -0.00264 │         0.00203 │  (-0.00738, 0.00114) │\r\n│ school │             -0.01197 │         0.01212 │  (-0.03718, 0.01118) │\r\n│     yr │             -0.02650 │         0.01224 │ (-0.04906, -0.00192) │\r\n└────────┴──────────────────────┴─────────────────┴──────────────────────┘","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"result=res: The returned result from sfmodel_fit() from the main estimation (in our example, res).\ndata=df: The dataset (in DataFrame format) used in sfmodel_fit(). If data was supplied using matrix (i.e., the Method 2 of sfmodel_spec()), this option should be skipped.\nR=100: The number of bootstrapped samples.\nlevel=0.05: The significance level of the confidence intervals. Optional (so not shown in the above example) with the default value equal to 0.05.\nseed=1232: Optional. A positive integer used to seed the random number generator (rng) in resampling, which ensures reproducibility. This rng is not global and is effective only in this function. If not specified, the global random number generator is used, and the bootstrap result may change (slightly) between runs.\niter=100: The iteration limit for each of the maximum likelihood estimation. The default is the one specified by main_maxIT() in sfmodel_opt().\ngetBootData=true: Whether to return the bootstrapped data which is R x K where K is the number of exogenous determinants of inefficiency. The default is false.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"See help on sfmodel_boot_marginal for other options.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"In this example, the function has two returns. The first one, which we saved in err_ci, is a 3times 2 matrix with the bootstrapped standard errors in the first column and the confidence intervals (tuples) in the 2nd column. The second return, which we saved in bsdata, is a 250 times 3 matrix of bootstrapped data. More specifically, the first column is the bootstrapped mean marginal effect of age collected from each of the 250 replications. The second and the third columns are the data for school and yr, respectively.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"If getBootData=false (the default), there would be only one return (the first one) from sfmodel_boot_marginal().","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"The saved bsdata data could be used for later analysis. For instance, to obtain confidence intervals at different significance levels, we could re-run sfmodel_boot_margina() again with a different value of level, but this is time consuming and absolutely unnecessary since the bootstrapped data is the same regardless of the significance levels. Instead, we may run sfmodel_boot_marginal() once and obtain bootstrapped data, and then apply it to sfmodel_CI() to get confidence intervals at different significance levels.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Here we use bsdata in sfmodel_CI() to get the 90% bias-corrected confidence intervals (i.e., at the 10% significance level).","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> sfmodel_CI(bootdata=bsdata, observed=res.marginal_mean, level=0.10)\r\n\r\nBias-Corrected 90.0% Confidence Interval:\r\n\r\n3×1 Matrix{Any}:\r\n (-0.00687, 0.00073)\r\n (-0.0316, 0.00695)\r\n (-0.04771, -0.00464)","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"bootdata=bsdata: The bootstrapped data of size R x K, where R is the number of bootstrap samples (replications) and    K is  the number of statistics.\nobserved=res.marginal_mean: The observed values of the statistics to which the confidence intervals are to be calculated. It could be Vector, Tuple, or NamedTuple. The length of observed should be equal to K. \nlevel=0.10: The significance level (default=0.05) of the bias-corrected confidence intervals.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Note that here we used observed=res.marginal_mean where res is the model estimation results we obtained earlier from res = sfmodel_fit(useData(df)), and marginal_mean is a field of res containing the mean of the three exogenous inefficiency determinants' marginal effects. We could have manually input the mean effects, e.g., observed=(-0.00264, -0.01197, -0.0265), and the result would be the same.","category":"page"},{"location":"ex_detail.html#.5-predicted-values-of-equations","page":"A Detailed Example","title":"5.5 predicted values of equations","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"SFrontiers provides the function sfmodel_predict() to obtain predicted values of model equations after the model is estimated. The following example returns the predicted value of the frontier equation, i.e., mathbfx hatbeta.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> xb = sfmodel_predict(@eq(frontier), df)   # predict equation `frontier`\r\n271-element Vector{Float64}:\r\n 5.870910806585876\r\n 5.491526404276636\r\n 5.162700470230824\r\n 5.5235030982431805\r\n 6.112704105091019\r\n 6.0987515622992206\r\n ⋮\r\n 4.916534395720751\r\n 6.418237370122121\r\n 8.208785623085882\r\n 7.895417236187299\r\n 8.549405592214674\r\n 6.399603902768199","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Note that df in the function is the name of the DataFrame which we had used to estimate the model. If matrix and vectors are used as data input, the argument can be skipped. The estimated composed error of the model, namely hatepsilon_i = hatv_i - hatu_i, is then obtained by df[:, :yvar] - xb.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Predicted values of other equations may be obtain in the similar way. For instance, sfmodel_predict(@eq( σᵤ² ),df).","category":"page"},{"location":"ex_detail.html#.-save-results-to-disk","page":"A Detailed Example","title":"6. save results to disk","text":"","category":"section"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"We may save the entire res dictionary or part of the results to the disk and load them later in other sessions for further analysis. There are several ways to do this. One is to save the dictionary in a binary file. Here we use the JLD2 package to save it in the HDF5 format.","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia> using JLD2    # which saves objects in HDF5-based Julia Data Format\r\n\r\njulia> save_object(\"model1.jld2\", res)       # save `res` dictionary to `model1.jld2`\r\njulia> result1 = load_object(\"model1.jld2\")  # load it back to `result1`\r\n\r\njulia> save_object(\"model1_jlms.jld2\", res.jlms)    # save only the JLMS inefficiency index\r\njulia> jlmsindex = load_object(\"model1_jlms.jld2\")  # load it back to `jlmsindex`","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"It is also possible to save some of the results in the good old text format which is cross-platform, version compatible, human-readable, and likely superior for the purpose of long-term storage. Here we use CSV.write() function from the CSV package that we have loaded earlier. A limitation of the function is that it only saves table-like or matrix-like data. We may not save the entire res dictionary with it. ","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"julia>   # save the marginal effects to `marginal.txt`\r\njulia> CSV.write(\"marginal.txt\", res.marginal );  # res.marginal is a DataFrame\r\n\r\njulia>   # save the coefficient vector to `coeff.txt`\r\nJulia> CSV.write(\"coeff.txt\", \r\n           DataFrame(reshape(res.coeff, length(res.coeff), 1), :auto), \r\n           header=true);              # res.coeff is a vector","category":"page"},{"location":"ex_detail.html","page":"A Detailed Example","title":"A Detailed Example","text":"Because res.coeff is a vector, it has to be converted into a matrix to use CSV.write. The reshape() bit is used for this purpose.","category":"page"},{"location":"installation.html#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"https://julialang.org/downloads/","category":"page"},{"location":"installation.html#Install-SFrontiers.jl-to-Julia","page":"Installation","title":"Install SFrontiers.jl to Julia","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"julia> using Pkg; Pkg.add(\"SFrontiers\"); ","category":"page"},{"location":"installation.html#Usage","page":"Installation","title":"Usage","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"julia> using SFrontiers","category":"page"},{"location":"installation.html#Run-Julia-script","page":"Installation","title":"Run Julia script","text":"","category":"section"},{"location":"installation.html#(Option)-Install-Jupyter-and/or-VSCode","page":"Installation","title":"(Option) Install Jupyter and/or VSCode","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"#### Jupyter\r\n* Pros: interactive, mixture of code and documents (Markdown, LaTeX)\r\n* Cons: no syntax highlighting, \r\n* good for: teaching, short work, documentation\r\n\r\n#### VSCode\r\n* Pros: syntax highlighting , intellisense (help coding)\r\n* Cons: documentation not as good\r\n* good for: code development, serious long project\r\n\r\nInstall Julia and Jupyter (Mandarin)\r\nhttps://www.youtube.com/watch?v=v7XeveI19CM&ab_channel=MasterTalks%E7%B7%9A%E4%B8%8A%E8%AA%B2%E7%A8%8B\r\n\r\nJupyter nbextensions\r\nhttps://www.youtube.com/watch?v=daEkgB9Utdc&ab_channel=%E8%80%81%E5%91%86%E7%8B%BC%E6%9D%82%E8%AE%B0myTiros\r\n\r\nabout Jupyter\r\nhttps://julia.quantecon.org/getting_started_julia/getting_started.html","category":"page"},{"location":"ex_panel.html#panel","page":"panel models","title":"Examples of Panel Stochastic Frontier Models","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Pages = [\"ex_panel.md\"]\r\nDepth = 5","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"note: Reminder\nAs shown in the A Detailed Example section, SFrontiers estimates stochastic frontier models in four steps:model specification using sfmodel_spec(),\ninitial values using sfmodel_init() (optional),\nmaximization options (and others) using sfmodel_opt() (optional),\nestimation using sfmodel_fit().Here we only highlight the first step of using sfmodel_spec() for different models.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"note: Additional Tags for Panel Model\nIn general, the panel model requires the additional tags of:sfpanel(): the model id, which currently includes TFE_CSW2014， TFE_WH2010, TRE, TimeDecay.\ntimevar(): variable of time period,\nidvar(): variable for individual identification.","category":"page"},{"location":"ex_panel.html#Panel-True-Fixed-Effect-Model","page":"panel models","title":"Panel True Fixed Effect Model","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"A general setup of this model is:","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n   y_it  = alpha_i +  x_it beta + epsilon_it\r\n   epsilon_it  = v_it - u_it\r\n   v_it sim N(0 sigma_v^2)   quad u_it  sim N^+(mu sigma_u^2)\r\nendaligned ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"where alpha_i is the time-invariant and individual-specific effect which is not directly observable. It is not the same as the inefficiency effect, the latter of which is represented by u_it. Here alpha_i is assumed to be a fixed parameter which allows arbitrary correlations with x_it. ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Greene (2005) coins the term true fixed effect for this setup in order to distinguish it from other panel SF models where the fixed effect has different interpretations. For instance, Schmidt and Sickles (1984) have alpha_i in the model and is also a fixed parameter. Their model, however, does not have u_it. They interpret the estimated alpha_i, after normalization, as the inefficiency effect. Thus their alpha_i is not the kind of fixed effect in the traditional sense and could be argued as a mixture of the individual effect and the inefficiency effect. Thus, true fixed effect emphasizes the existence of both of the individual effect alpha_i and the inefficiency effect u_it in the model, both of distinct interpretations.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The challenge of estimating such a model is the incidental parameters problem arising from alpha_i. For a linear panel data model, it is common to get rid of alpha_i before estimation by first-differencing or within-transforming the model. This approach, however, is thought to be infeasible to the above panel SF model because we could not derive the closed-form likelihood function after the model transformation. It was later proven to be not true (see Chen, Schmidt, and Wang 2014).","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Here ``N^+(0, \\sigma_u^2)`` is a _half-normal distribution_ obtained by truncating the normal distribution ``N(0, \\sigma_u^2)`` from below at 0. ``z_i^v`` and ``z_i^u`` are vectors of exogenous variables including a constant, and the two vectors need not be the same. If, for instance, ``z_i^v`` has only a constant, ``\\sigma_v^2`` is a constant parameter.\r\n\r\nBoth ``\\sigma_v^2`` and ``\\sigma_u^2`` are parameterized using exponential functions to ensure positive values. In the case of ``\\sigma_v^2``, it is ``\\sigma_v^2 = \\exp(c_v)``, where ``c_v \\in R`` is an unconstrained constant, and the log-likelihood maximization is w.r.t. ``c_v`` (among others).","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Let's assume we have a panel dataset containing the production data of N farmers at the annual frequency for T years. We could have T to be different across farmers, i.e., T_i. We assume the dataset is named df and is in the DataFrame format and has the following column names (aka variables):","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"y: production output,\nx1, x2, x3: production input,\nz1, z2: factors that may affect production efficiency,\n_cons: a constant variable with values equal to 1,\nyr: year of production,\nid: individual farmer's identification number.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"\n","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"First, call in the main packages.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"using SFrontiers\r\nusing CSV, DataFrames","category":"page"},{"location":"ex_panel.html#TFE-with-dummy-variables-([Greene-2005,-Wang-2003](@ref-literature))","page":"panel models","title":"TFE with dummy variables (Greene 2005, Wang 2003)","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"This approach simply uses dummy variables to estimate alpha_i, i=1ldotsN. Thus, it can be estimated using  cross-sectional models by adding dummy variables in the frontier() equation. To generate dummy variables from id in the original DataFrame, one may try this method:","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"df = CSV.read(\"panel_example.csv\", DataFrame; header=1, delim=\",\")\r\ndf[!, :_cons] .= 1.0\r\n\r\nuid = unique(df.id);\r\ndf = transform(df, @. :id => ByRow(isequal(uid)) .=> Symbol(:dummy, uid))","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"We may want to see what is inside the data now.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"julia> describe(df)\r\n106×8 DataFrame\r\n│ Row │ variable │ mean      │ min      │ median     │ max     │ nunique │ nmissing │ eltype   │\r\n│     │ Symbol   │ Float64   │ Real     │ Float64    │ Real    │ Nothing │ Nothing  │ DataType │\r\n├─────┼──────────┼───────────┼──────────┼────────────┼─────────┼─────────┼──────────┼──────────┤\r\n│ 1   │ id       │ 50.5      │ 1        │ 50.5       │ 100     │         │          │ Int64    │\r\n│ 2   │ time     │ 3.5       │ 1        │ 3.5        │ 6       │         │          │ Int64    │\r\n│ 3   │ y        │ 0.425722  │ -3.76222 │ 0.400012   │ 3.66662 │         │          │ Float64  │\r\n│ 4   │ x1       │ 0.510121  │ -2.41952 │ 0.517722   │ 3.79116 │         │          │ Float64  │\r\n│ 5   │ x2       │ -0.019732 │ -3.09178 │ 0.00775225 │ 2.99767 │         │          │ Float64  │\r\n│ 6   │ _cons    │ 1.0       │ 1.0      │ 1.0        │ 1.0     │         │          │ Float64  │\r\n│ 7   │ dummy1   │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 8   │ dummy2   │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n⋮\r\n│ 98  │ dummy92  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 99  │ dummy93  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 100 │ dummy94  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 101 │ dummy95  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 102 │ dummy96  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 103 │ dummy97  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 104 │ dummy98  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 105 │ dummy99  │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │\r\n│ 106 │ dummy100 │ 0.01      │ 0        │ 0.0        │ 1       │         │          │ Bool     │","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"This approach may be easier to carry out using SFrontiers's matrix-input method in order to avoid manually inputting the dummy variable names which are quite many.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"xvar = Matrix(df[:, [:x1, :x2]])\r\nalldummy = Matrix(df[:, 8:106]) # skip the first dummy to avoid multicollinearity\r\nxMat = hcat(xvar, alldummy) # combine all of the frontier var\r\nyMat = Matrix(df[:, [:y]])\r\ncMat = Matrix(df[:, [:_cons]])\r\n\r\nsfmodel_spec(sftype(prod), sfdist(half),  \r\n             depvar(yMat), \r\n             frontier(xMat), \r\n             σᵤ²(cMat),\r\n             σᵥ²(cMat))","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The rest of the estimation procedures is the same as in other models. In addition to the computational problem (having to estimate a large number of parameters), the approach suffers from the incidental parameters problem (Wang and Ho 2010). The estimates are consistent only when T is large (Greene 2005).","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"\n","category":"page"},{"location":"ex_panel.html#TFE-with-skew-normal-approach-([Chen,-Schmidt,-and-Wang-2014](@ref-literature))","page":"panel models","title":"TFE with skew-normal approach (Chen, Schmidt, and Wang 2014)","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The authors use results from the closed skew-normal literature and derive the model's closed-form likelihood function after first-differencing or within transforming the model. The model id is TFE_CSW2014.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"sfmodel_spec(sfpanel(TFE_CSW2014), sftype(prod), sfdist(half),\r\n             @timevar(yr), @idvar(id),\r\n             @depvar(y), \r\n             @frontier(x1, x2, x3), \r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The user does not have to first-difference or within-transform the data; the program will perform the transformation.\n_cons cannot be included in @frontier(), because alpha_i is a fixed parameter, and including _cons in addition to a full set of alpha_i would cause multicollinearity.\nThe model does not support exogenous determinants of inefficiency.\nsfdist() only supports half.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"\n","category":"page"},{"location":"ex_panel.html#TFE-with-scaling-property-and-inefficiency-determinants-([Wang-and-Ho-2010](@ref-literature))","page":"panel models","title":"TFE with scaling property and inefficiency determinants (Wang and Ho 2010)","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Wang and Ho (2010) propose a model where the u_it is modeled as","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n  u_it  = h(z_it delta)cdot u_i^*\r\n  u_i^*  sim N^+(mu sigma_u^2)\r\nendaligned","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"where","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n   h(z_it delta)  = exp(z_itdelta)\r\n   sigma_u^2  = exp(c_u)\r\nendaligned","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Both of mu and sigma_u^2 are constant, and mu may equal 0 for a half-normal assumption.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The specification has two advantages: (1) The closed-form likelihood function can be derived using the conventional method. (2) The model can easily accommodate exogenous determinants of inefficiency. The model is TFE_WH2010.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"sfmodel_spec(sfpanel(TFE_WH2010), sftype(prod), sfdist(trun),\r\n             @timevar(yr), @idvar(id),\r\n             @depvar(y), \r\n             @frontier(x1, x2, x3), \r\n             @μ(_cons),\r\n             @hscale(z1, z2),                # h(.) function\r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The user does not have to first-difference or within-transform the data; the program will perform the transformation.\n_cons cannot be included in @frontier(), because alpha_i is a fixed parameter.\nGiving sfdist(half) and omitting @μ() will estimate the model with the half-normal distribution.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"\n","category":"page"},{"location":"ex_panel.html#Panel-True-Random-Effect-Model","page":"panel models","title":"Panel True Random Effect Model","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The model is attributed to Greene (2005). It assumes alpha_i to be a value from a random variable. We assume that ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n  alpha_i    sim N(0 sigma_a^2)\r\n  sigma_a^2   = exp(c_a)\r\nendaligned  ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"where c_a in R is a constant. The model id is TRE.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"sfmodel_spec(sfpanel(TRE), sftype(prod), sfdist(half),\r\n             @timevar(yr), @idvar(id),\r\n             @depvar(y), \r\n             @frontier(x1, x2, _cons), \r\n             @σₐ²(_cons),\r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The constant _cons is included in @frontier() since alpha_i is random.\nGiving sfdist(trun) and @μ(_cons) will estimate the model with the truncated-normal distribution.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"\n","category":"page"},{"location":"ex_panel.html#Panel-Time-Decay-Model","page":"panel models","title":"Panel Time Decay Model","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The model is attributed to Battese and Coelli (1992).","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n   y_it  = alpha_0 +  x_it beta + epsilon_it\r\n   epsilon_it  = v_it - u_it\r\n   v_it sim N(mu_i sigma_v^2)   \r\n   u_it sim G(t) u_i^* quad u_i^* sim N^+(0 sigma_u^2)\r\nendaligned ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"where ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n  G(t)  = expgamma (t_i  T_i)\r\n  sigma_u^2  = exp(c_u)\r\nendaligned  ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"In the specification, G(t) is a function of time t_i, and T_i = mathrmmax(t_i) is fixed for an individual. A positive estimate of gamma thus indicates a decreasing of inefficiency over time (i.e., time decay). The mu_i can be a function of individual specific variable or a constant (mu_i = mu). ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Note that the frontier function has an overall intercept alpha_0 but there is no individual effect alpha_i in the model, and so it does not belong to the class of true-fixed or true-random effect model. The model is TimeDecay.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Kumbhakar and Wang (2005) use a variant of the model to study growth convergence of a panel of countries, where they have mu_i as the country's initial capital stock per capita when data began in the 1960s. We assume w to be such a variable in the following example.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"using Statistics, DataFramesMeta  # helps to get `yearT_i = yr_i - max(yr_i)`\r\n\r\n# assume `df` is already loaded \r\ngdf = groupby(df, :id)               # info of data grouping\r\ndf = @transform(gdf, yearT = :yr .-  maximum(:yr))   # create yearT\r\n\r\n\r\nsfmodel_spec(sfpanel(TimeDecay), sftype(prod), sfdist(trun),\r\n             @timevar(yr), @idvar(id),\r\n             @depvar(y), \r\n             @frontier(x1, x2, x3, _cons), \r\n             @μ(w, _cons),\r\n             @gamma(yearT),              # the G(.) function\r\n             @σᵤ²(_cons),\r\n             @σᵥ²(_cons))","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"\n","category":"page"},{"location":"ex_panel.html#Panel-Model-of-Kumbhakar-(1990)","page":"panel models","title":"Panel Model of Kumbhakar (1990)","text":"","category":"section"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"The model is attributed to Kumbhakar (1990).","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n   y_it  = alpha_0 +  x_it beta + epsilon_it\r\n   epsilon_it  = v_it - u_it\r\n   v_it sim N(mu_i sigma_v^2)   \r\n   u_it sim G(t) u_i^* quad u_i^* sim N^+(0 sigma_u^2)\r\nendaligned ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"where ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"beginaligned\r\n  G(t)  = 2 times 1 + exp(gamma_1 (t_i  T_i) + gamma_2 (t_i  T_i)^2)^-1\r\n  sigma_u^2  = exp(c_u)\r\nendaligned  ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Similar to the previous model, G(t) is a function of time t_i, and T_i = mathrmmax(t_i) is fixed for an individual. The mu_i can be a function of individual specific variable or a constant (mu_i = mu). ","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"Note that the frontier function has an overall intercept alpha_0 but there is no individual effect alpha_i in the model, and so it does not belong to the class of true-fixed or true-random effect model. The model id is Kumbhakar1990.","category":"page"},{"location":"ex_panel.html","page":"panel models","title":"panel models","text":"\r\ngdf = groupby(df, :id)               # info of data grouping\r\ndf = @transform(gdf, yearT = :yr .-  maximum(:yr))   # create yearT\r\ndf[!, :yearT2] = df.yearT.^2;\r\n\r\nsfmodel_spec( sfpanel(Kumbhakar1990), sftype(production), sfdist(trun),\r\n              @timevar(yr), @idvar(code),\r\n              @depvar(lny), \r\n              @frontier(lnk, lnl, yr, _cons), \r\n              @μ(iniStat, _cons),\r\n              @gamma(yearT, yearT2),\r\n              @σᵤ²(_cons),\r\n              @σᵥ²(_cons))","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"SFrontiers.jl provides commands for estimating various parametric stochastic frontier models in Julia. The commands estimate model parameters, calculate efficiency and inefficiency index, compute marginal effects of inefficiency determinants (if any), and with the option of bootstrapping standard errors of the mean marginal effects. ","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Collaboration to further develop the package is more than welcome.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"The package's GitHub page.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"@contents\r\nPages = [\"literature.md\", \"overview.md\"]\r\nDepth = 3","category":"page"},{"location":"index.html#What-is-a-stochastic-frontier-model?","page":"Home of SFrontiers.jl","title":"What is a stochastic frontier model?","text":"","category":"section"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"note: in a nutshell\nAn econometric model where the composed error consists of a one-sided (either positive or negative) term and the usual zero-mean error term. The model is usually estimated by MLE. Applications include production efficiency and others that may have upper bounds (e.g., potential output) or lower bounds (e.g., minimum cost) interpretations on the dependent variable.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"A stochastic frontier (SF) model was originally proposed in the production function context to account for the production frontier (potential output) and the shortfall of the output from the frontier due to technical inefficiency. The latter is usually modeled as a one-sided deviation from the frontier. The model has since been extended to study other issues, such as underpayment in the job market due to labor market frictions, the financing constraints hypothesis of capital investment, growth convergence, underpricing of IPO, etc..","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"A typical SF model in the production function context may be represented as","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Y_i = F(X_i beta)e^v_i - u_i","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"taking logarithms on both sides and imposing simplifying assumptions on F(), we have","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":" y_i  = alpha_0 + x_i beta + v_i - u_i","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Here v_i is the zero-mean random error and u_i0 is output loss due to technical inefficiency. Both are usually assumed to be stochastic and follow certain distributions.  We may define y_i^* = alpha_0 + x_i beta + v_i as the stochastic frontier, and observed output y_i is the frontier output minus the inefficiency effect, i.e., y_i = y_i^* - u_i. The model is often estimated by the maximum likelihood method based on the distribution assumptions of v_i and u_i.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":" v_i \\sim N(0, \\sigma_v^2),\\\\\r\n u_i \\sim N^+(\\mu, \\sigma_u^2),\r\nHere ``N^+(\\cdot)`` denotes a non-negative truncation of the underlying normal distribution\r\nfrom below. ","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Exogenous determinants of inefficiency, z_i, may be parameterized into the distribution function of u_i, and the marginal effects of z_i on the unconditional mean of inefficiency E(u_i) can be computed. The focus of a SF analysis also includes calculating the inefficiency index E(umid v_i - u_i) and the efficiency index E(exp(u_i) mid v_i - u_i) for each observation in the data.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"A typical panel SF model can be similarly defined:","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"y_it = alpha_i + x_it beta + v_it - u_it","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Here, alpha_i is the individual's unobservable effect which is different from the inefficiency effect. The model is the so-called true fixed effect panel SF model if alpha_i is assumed to be a fixed parameter, and the true random effect panel SF model if it is a value from a random variable. Other variants of the panel model may be obtained by making extra assumptions on alpha_i, u_it, and v_it.","category":"page"},{"location":"index.html#Why-Julia?","page":"Home of SFrontiers.jl","title":"Why Julia?","text":"","category":"section"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"note: TL;DR\nSpeed and accuracy. The latter also translates into easier convergence in maximum likelihood estimation. In some cases, Julia helps to turn the problem's convergence issue from art to science. ","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Parametric SF models are highly nonlinear, which often presents challenges to maximum likelihood estimation. Recent developments in the literature also grow reliance on simulations and bootstrapping. Julia's strength helps to meet the demand.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"SFrontiers uses Julia's Optim package as the basis to do MLE, and I found it versatile and robust. It offers an array of solvers, including non-gradient (e.g., Nelder Mead), gradient-based (e.g., BFGS), and Hessian-based algorithms (e.g., Newton). It also has a global optimization algorithm (i.e., Particle Swarm).  An effective estimation strategy for difficult problems is to use non-gradient methods in the first stage of the estimation to zoom in to the neighborhood of the solution and then switch to gradient-based ones. The strategy is easily implemented in SFrontiers using Optim, and I found it very useful.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Optim could use automatic differentiation from the package ForwardDiff to calculate gradients and Hessians for the gradient- and Hessian-based algorithms. The automatic differentiation is different from symbolic differentiation and numerical finite differentiation. It in fact has the best of both worlds: it is as accurate as the analytic derivatives and it does not require users' supply of analytic formula (nor supply anything other than the log-likelihood function itself). Using automatic differentiation significantly improves estimation speed and accuracy. All of the models estimated by SFrontiers use automatic differentiation by default.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"The automatic differentiation also provides an easy way to compute marginal effects of inefficiency determinants.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Julia is fast. Very fast. Some claim it can be as fast as C. This gives Julia an important edge in simulation-based estimation.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Julia has a large ecosystem for optimization and modeling, including JuMP, Optim, BlackBoxOptim, NLopt, NLsolve, and others. Some of which could be useful for SF research in the future.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Julia language's multiple dispatch feature makes it easy to collaborate and contribute. People who wish to make other models available via SFrontiers can add their own relatively easily without worry too much about breaking other parts of the package.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Julia's is free and open source.","category":"page"},{"location":"index.html#literature","page":"Home of SFrontiers.jl","title":"What Models are Covered by SFrontiers?","text":"","category":"section"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"note: quick peek\ncross-sectional: v_i is a normal distribution and u_i follows half normal, truncated normal, or exponential distributions, with the distribution flexibly parameterized by vectors of exogenous determinants. Also, the scaling property model. \npanel: various flavors of true fixed effect models (Greene 2005, Wang and Ho 2010, Chen, Wang, and Schmidt 2014), true random effect model, time decay model.\nin the pipeline: two-tier frontier models with exogenous determinants, moment estimator and moment tests, time series autocorrelation models, semi-parametric models, and models with exotic distributions estimated by maximum simulated likelihoods.","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"The following is a partial list of articles for which the models are covered by (can be estimated by) routines in SFrontiers. If there is anything missing, please inform me and I will be happy to update the list. ","category":"page"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"Aigner, D., Lovell, C. A. K., & Schmidt, P. (1977). Formulation and Estimation of Stochastic Frontier Production Function Models. Journal of Econometrics, 6, pp. 21-37. \nAlvarez, A., Amsler, C., & Schmidt, P. (2006). Interpreting and Testing the Scaling Property in Models where Inefficiency Depends on Firm Characteristics. Journal of Productivity Analysis, 25, pp. 201-212. \nBattese, G. E., & Coelli, T. J. (1988). Prediction of Firm-Level Technical Efficiencies with a Generalized Frontier Production Function and Panel Data. Journal of Econometrics, 38, pp. 387-399.\nBattese, G. E., & Coelli, T. J. (1992). Frontier Production Functions, Technical Efficiency and Panel Data: With Application to Paddy Farmers in India. Journal of Productivity Analysis, 3, pp. 153-169. \nBattese, G. E., & Coelli, T. J. (1995). A Model for Technical Inefficiency Effects in a Stochastic Frontier Production Function for Panel Data. Empirical Economics, 20, pp. 325-332. \nBera, A. K., & Sharma, S. C. (1999). Estimating Production Uncertainty in Stochastic Frontier Production Function Models. Journal of Productivity Analysis, 12, pp. 187-210. \nCaudill, S. B., & Ford, J. M. (1993). Biases in Frontier Estimation Due to Heteroscedasticity. In Economics Letters, 41, pp. 17-20.\nChen, Y. T., & Wang, H. J. (2012). Centered-Residuals-Based Moment Estimator and Test for Stochastic Frontier Models. Econometric Reviews, 31(6), 625-653. \nChen, Y. Y., Schmidt, P., & Wang, H. J. (2014). Consistent estimation of the fixed effects stochastic frontier model. Journal of Econometrics, 181(2), 65-76. \nCoelli, T., Perelman, S., & Romano, E. (1999). Accounting for Environmental Influences in Stochastic Frontier Models: With Application to International Airlines. Journal of Productivity Analysis, 11, pp. 251-273. \nColombi, R., Kumbhakar, S. C., Martini, G., & Vittadini, G. (2014). Closed-skew normality in stochastic frontiers with individual effects and long/short-run efficiency. Journal of Productivity Analysis, 42(2), 123-136. \nGreene, W. (2004). Distinguishing between heterogeneity and inefficiency: stochastic frontier analysis of the World Health Organization's panel data on national health care systems. Health Economics, 13(10), 959-980. \nGreene, W. (2005). Reconsidering heterogeneity in panel data estimators of the stochastic frontier model. Journal of Econometrics, 126, 269-303. \nHuang, C. J., & Liu, J. T. (1994). Estimation of a Non-neutral Stochastic Frontier Production Function. Journal of Productivity Analysis, 5, pp. 171-180. \nHuang, Y. F., Luo, S., & Wang, H. J. (2018). Flexible panel stochastic frontier model with serially correlated errors. Economics Letters, 163, 55-58.\nJondrow, J., Lovell, C. A. K., Materov, I. S., & Schmidt, P. (1982). On the Estimation of Technical Inefficiency in the Stochastic Frontier Production Function Model. Journal of Econometrics, 19, pp. 233-238. \nKumbhakar, S. C. (1990). Production Frontiers, Panel Data, and Time-Varying Technical Inefficiency. Journal of Econometrics, 46, pp. 201-211.\nKumbhakar, S. C., Ghosh, S., & McGuckin, J. T. (1991). A Generalized Production Frontier Approach for Estimating Determinants of Inefficiency in U.S. Dairy Farms. Journal of Business and Economic Statistics, 9, pp. 279-286.\nKumbhakar, S. C., & Wang, H.-J. (2005). Estimation of Growth Convergence Using a Stochastic Production Frontier Approach. In Economics Letters, 88, pp. 300-305.\nStevenson, R. E. (1980). Likelihood Functions for Generalized Stochastic Frontier Estimation. Journal of Econometrics, 13, pp. 57-66.\nWang, H.-J. (2002). Heteroscedasticity and Non-monotonic Efficiency Effects of a Stochastic Frontier Model. Journal of Productivity Analysis, 18, pp. 241-253.\nWang, H.-J. (2003). A Stochastic Frontier Analysis of Financing Constraints on Investment: The Case of Financial Liberalization in Taiwan. Journal of Business and Economic Statistics, 21, pp. 406-419.\nWang, H.-J., & Ho, C.-W. (2010). Estimating Fixed-Effect Panel Stochastic Frontier Models by Model Transformation. Journal of Econometrics, 157, 289-296. \nWang, H.-J., & Schmidt, P. (2002). One-Step and Two-Step Estimation of the Effects of Exogenous Variables on Technical Efficiency Levels. Journal of Productivity Analysis, 18, pp. 129-144.","category":"page"},{"location":"index.html#Citing-**SFrontiers**","page":"Home of SFrontiers.jl","title":"Citing SFrontiers","text":"","category":"section"},{"location":"index.html","page":"Home of SFrontiers.jl","title":"Home of SFrontiers.jl","text":"If you find __SFrontiers.jl__ useful for your research, please cite the following paper:\r\n\r\n@Article{wang_2021,\r\n  author        = {Wang, Hung-Jen},\r\n  journal       = {n.a.},\r\n  title         = {SFrontiers: Stochastic Frontier Analysis using Julia},\r\n  year          = {hopefully 2021},\r\n  archiveprefix = {arXiv},\r\n  eprint        = {n.a.},\r\n  keywords      = {stochastic frontier analysis},\r\n  primaryclass  = {??},\r\n  url           = {n.a.},\r\n}","category":"page"}]
}
