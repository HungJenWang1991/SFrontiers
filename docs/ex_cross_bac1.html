<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cross Section Models · Stochastic Frontier Analysis using Julia</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-134239283-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-134239283-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Stochastic Frontier Analysis using Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Stochastic Frontier Analysis using Julia</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home of SFrontiers.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="overview.html">Estimation Overview</a></li><li><a class="tocitem" href="ex_detail.html">A Detailed Example</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Other Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ex_cross.html">cross-sectional models</a></li><li><a class="tocitem" href="ex_panel.html">panel models</a></li></ul></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="ex_cross_bac1.html">Cross Section Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ex_cross_bac1.html">Cross Section Models</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cross-Section-Models"><a class="docs-heading-anchor" href="#Cross-Section-Models">Cross Section Models</a><a id="Cross-Section-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-Section-Models" title="Permalink"></a></h1><p>Consider the following equation:</p><p class="math-container">\[ \mathbf{y}  =  \mathbf{x} \beta + \mathbf{v} - \mathbf{u},\]</p><p>where <span>$\mathbf{y}$</span> is <span>$(N\times 1)$</span>, <span>$\mathbf{x}$</span> is <span>$(N\times k)$</span> and includes a column of 1 for intercept, and <span>$\beta$</span> is <span>$(k \times 1)$</span>. <span>$\mathbf{v}$</span> and <span>$\mathbf{u}$</span> are stochastic and assumed to follow certain distribution assumption. </p><p>Our goal is to estimate <span>$\beta$</span> and parameters associated with <span>$\mathbf{v}$</span> and <span>$\mathbf{u}$</span>.</p><p>In the follows, we use <span>$x_i$</span> (which is (<span>$1 \times k$</span>)) to denote the <span>$i$</span>th observation of <span>$\mathbf{x}$</span>. Other notations follow similarly.</p><h2 id="Normal-Truncated-Normal-Model"><a class="docs-heading-anchor" href="#Normal-Truncated-Normal-Model">Normal Truncated-Normal Model</a><a id="Normal-Truncated-Normal-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-Truncated-Normal-Model" title="Permalink"></a></h2><p>For the individual <span>$i$</span>, the composed error consists of <span>$v_i$</span> and <span>$u_i$</span> with the following distribution assumptions:</p><p class="math-container">\[\begin{aligned}
 v_i &amp; \sim N(0, \sigma_v^2),\\
 u_i &amp; \sim N^+(\mu, \sigma_u^2),
 \end{aligned}\]</p><p>where <span>$N^+(\mu, \sigma_u^2)$</span> denotes a <em>truncated normal distribution</em> obtained by truncating the normal distribution <span>$N(\mu, \sigma_u^2)$</span> from below at 0. The <span>$\mu$</span> and <span>$\sigma_u^2$</span> are thus the mean and the variance of the normal distribution <em>before</em> the truncation. </p><p>In the likelihood function, the variance <span>$\sigma_v^2$</span> and <span>$\sigma_u^2$</span> are specified using exponential functions to ensure positive values. That is,</p><p class="math-container">\[  \sigma_v^2 = \exp(z_i^v \gamma),\\
  \sigma_u^2 = \exp(z_i^u \delta),\]</p><p>where <span>$z_i^v$</span> and <span>$z_i^u$</span> are vectors of variables. If an intercept is desired (most likely), one of variables in the vector needs to be the <em>constant variable</em> with a value equal to 1. </p><p>There are two ways to provide data for estimation. One is to use data from a DataFrame where column names of the data are variable names. The other is to use data from matrix or vectors. This is the likely scenario in simulation studies where computer generated data is used in estimation. Different ways of obtaining data would require different ways to specify the model. We start with the DataFrame approach.</p><h4 id="Step-1:-Use-DataFrame-and-Specify-the-Model-using-sfmodel_spec()"><a class="docs-heading-anchor" href="#Step-1:-Use-DataFrame-and-Specify-the-Model-using-sfmodel_spec()">Step 1: Use DataFrame and Specify the Model using <code>sfmodel_spec()</code></a><a id="Step-1:-Use-DataFrame-and-Specify-the-Model-using-sfmodel_spec()-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Use-DataFrame-and-Specify-the-Model-using-sfmodel_spec()" title="Permalink"></a></h4><p>We use the production data from paddy farmers in India. The <span>$\mathbf{y}$</span> is the annual rice production and <span>$\mathbf{x}$</span> is agricultural inputs. The dataset is in the <code>.csv</code> format and we read it in using the <code>CSV</code> package and save it as a DataFrame with the name <code>df</code>.</p><pre><code class="language-julia hljs">using SFrontiers, Optim    # main packages
using DataFrames, CSV   # handling data

df = CSV.read(&quot;sampledata.csv&quot;, DataFrame; header=1, delim=&quot;,&quot;)
df[!, :_cons] .= 1.0;         # append a column of 1 to be used as a constant</code></pre><p>Note that we append a column of 1 to <code>df</code> with the column name <code>_cons</code>. This is essential because we need the constant variable to estimate intercepts. Before estimation, users should make sure that <code>df</code> contains no missing values or any anomaly that may affect the estimation.</p><p>Next, we give specifications of the type of model we wish to estimate using <code>sfmodel_spec()</code>. We start with the specification of the Battese and Coelli (1995) model where <span>$\mu$</span> is parameterized as a linear function of a vector of exogenous variables and <span>$\sigma_u^2$</span> and <span>$\sigma_v^2$</span> are constant parameters. </p><pre><code class="language-julia hljs">sfmodel_spec(SFtype(prod), SFdist(trun),
             @depvar(yvar), 
             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons), 
             @μ(age, school, yr, _cons),
             @σᵤ²(_cons),
             @σᵥ²(_cons))</code></pre><ul><li><code>SFtype(prod)</code> indicates a production-frontier type of model. The alternative is <code>cost</code> for cost frontier where the composed error is <span>$v_i + u_i$</span>.</li><li><code>SFdist(trun)</code> specifies the truncated-normal distribution assumption on <span>$u_i$</span>. Alternatives include <code>half</code>, <code>expo</code>, and <code>trun_scaling</code>.</li><li><code>@depvar(.)</code> specifies the dependent variable.</li><li><code>@frontier(.)</code> specifies the list of variables used in the frontier equation (i.e., the data of <span>$\mathbf{x}$</span>). The variables are assumes to be linear in the equation.</li><li><code>@μ(.)</code> (or <code>@mu(.)</code>) specifies the variables of inefficiency determinants as a linear function in <code>μ</code>.</li><li><code>@σᵤ²(.)</code> (or <code>@sigma_u_2(.)</code>) and <code>@σᵥ²(.)</code> (or <code>@sigma_v_2(.)</code>) specify the variables to parameterize the variances. Note that here we include only the variable <code>_cons</code> and so <span>$\sigma_v^2$</span> and <span>$\sigma_u^2$</span> are both estimated as constant parameters.</li></ul><p>Note how the constant parameters <span>$\sigma_v^2$</span> and <span>$\sigma_u^2$</span> are estimated. Using <span>$\sigma_u^2$</span> as an example, we have</p><p class="math-container">\[  \sigma_u^2 = \exp(z_i^u \delta)\]</p><p>where <span>$z_i^2$</span> is the constant variable <code>_cons</code>.</p><div class="admonition is-success"><header class="admonition-header">Note on intercepts and constant parameters</header><div class="admonition-body"><p><strong>SFrontiers</strong> estimates intercepts and constant parameters as the coefficient of a constant variable. That is, if a parameter is constant, <strong>SFrontiers</strong> requires a variable with values equal to 1. This is true for all equations. </p></div></div><h4 id="Step-2:-Specify-Initial-Vaules-using-sfmodel_init()-*(optional)*"><a class="docs-heading-anchor" href="#Step-2:-Specify-Initial-Vaules-using-sfmodel_init()-*(optional)*">Step 2: Specify Initial Vaules using <code>sfmodel_init()</code> <em>(optional)</em></a><a id="Step-2:-Specify-Initial-Vaules-using-sfmodel_init()-*(optional)*-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Specify-Initial-Vaules-using-sfmodel_init()-*(optional)*" title="Permalink"></a></h4><p>The specification is optional. You can skip it entirely or specify the initial values for a partial list of the equations. If missing (all or part of the equations), default values will be used. Currently, the default uses the OLS estimates as initial values for the <code>frontier()</code> equation and <span>$0.1$</span> for all of the other parameters. The following example shows a mix of the strategies.</p><pre><code class="language-julia hljs">b1 = ones(4)*(0.1)

sfmodel_init(    # frontier(),
             μ(b1),
                 # σᵤ²(-0.1),
             σᵥ²(-0.1)) </code></pre><p>The order of equations in <code>sfmodel_init()</code> is not important. </p><p>Note that because of the exponential parameterization on <code>σᵤ²</code> and <code>σᵥ²</code>, the initial values are given to the <code>log(σᵤ²)</code> and <code>log(σᵥ²)</code>. In the above example where we have <code>σᵥ²(-0.1)</code>, it means we have in mind the initial value of <code>σᵥ²</code> being <span>$\exp(-0.1) = 0.905$</span>.</p><p>You may notice that equation names (<code>frontier</code>, <code>μ</code>, etc.) are similar to those in <code>sfmodel_spec()</code> but different. <code>sfmodel_spec()</code> uses the macros type of names (those with &quot;<code>@</code>&quot;) and here <code>sfmodel_init()</code> uses function type of names (those without &quot;<code>@</code>&quot;).</p><div class="admonition is-success"><header class="admonition-header">Note on `@frontier( )` vs. `frontier( )`</header><div class="admonition-body"><p>Macro type of equation names (<code>@frontier()</code>, <code>@μ()</code>, etc.) are used only when the arguments are column names from DataFrames. For everything else, function type of equation names (<code>frontier()</code>, <code>μ()</code>, etc.) are used.</p></div></div><div class="admonition is-success"><header class="admonition-header">Note on name conflict</header><div class="admonition-body"><p><strong>SFrontiers</strong> uses names such as <code>μ</code>, <code>σᵥ²</code>, <code>gamma</code>, <code>depvar</code>, <code>frontier</code>, etc.. If users had used the same names elsewhere in the program for different purposes (for instance, using <code>μ</code> to denote the value of a parameter), or users import other packages that use the same names, name conflicts would arise. Signs of the problem include error messages such as </p><pre><code class="nohighlight hljs">MethodError: objects of type ... are not callable</code></pre><p>There are simple ways to work around:</p><ul><li>Use fully qualified function names. For instance, use <code>SFrontiers.σᵥ²</code> instead of <code>σᵥ²</code>.</li><li>Use alias if there is one. For instance, use <code>sigma_v_2</code> instead of <code>σᵥ²</code>. Check the section of <code>API Reference</code> for the information.</li></ul></div></div><h4 id="Step-3:-Specify-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*"><a class="docs-heading-anchor" href="#Step-3:-Specify-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*">Step 3: Specify Maximization Options (and others) using <code>sfmodel_opt()</code> <em>(optional)</em></a><a id="Step-3:-Specify-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Specify-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*" title="Permalink"></a></h4><p>The main purpose of this function is to select options for the numerical maximization procedures, including the choice of optimization algorithms, the number of iterations, the convergence criterion, and others. <strong>SFrontiers</strong> uses Julia&#39;s <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><code>Optim</code></a> package to do the maximization, and a subset of <code>Optim</code>&#39;s options are directly accessible through <code>sfmodel_init()</code>.</p><p>An effective estimation strategy for challenging optimization problems is to use a non-gradient algorithm in the first stage (<code>warmstart</code>) for a few iterations and then switch to gradient-based algorithms in the second stage (<code>main</code>) for speed and accuracy. <strong>SFrontiers</strong> uses the two-step strategy as default.</p><p>This function is also optional. All or part of the specifications may be skipped. If missing, default values will be used. The following example uses the default values.</p><pre><code class="language-julia hljs">sfmodel_opt(warmstart_solver(NelderMead()),   
            warmstart_maxIT(100),
            main_solver(Newton()), 
            main_maxIT(2000), 
            tolerance(1e-8))</code></pre><ul><li><code>warmstart_solver(NelderMead())</code>: specifies the <code>Nelder-Mead</code> algorithm in the first stage estimation. Mind the braces &quot;<code>()</code>&quot; which is part of the algorithm name. Using a non-gradient algorithm in the first stage is recommended.</li><li><code>warmstart_maxIT(100)</code> and <code>main_maxIT(2000)</code>: the maximum numbers of iterations in the first and the second stage estimation.</li><li><code>main_solver(Newton())</code>: specifies the <code>Newton</code> method in the second stage estimation. </li><li><code>tolerance(1e-8)</code>: set the convergence criterion, which is with respect to the absolute tolerance in the gradient, to <code>1e-8</code>. For non-gradient algorithms, it controls the main convergence tolerance, which is solver specific. This is a wrapper of <code>Optim</code>&#39;s <code>g_tol</code> option.</li></ul><p>If the two-stage strategy is not required, the <code>warmstart</code> stage can be skipped by giving empty keyword values to the first stage options, such as <code>warmstart_solver()</code> or <code>warmstart_maxIT()</code>, or both. Note that if we simply skip the keywords (i.e., missing <code>warmstart_solver</code> or <code>warmstart_maxIT</code> entirely), the default will be reinstate. Again, the first stage estimation will only be skipped when empty values are explicitly given to the the related options.</p><p>In <strong>SFrontiers</strong>, <em>missing</em> = &quot;<em>Whatever. Just use the default</em>&quot;, and <em>empty value</em> = &quot;<em>I know, but don&#39;t do it</em>&quot;.</p><p>In addition to controlling the maximization procedures, <code>sfmodel_opt()</code> also provides options to control other parts of the estimation. They and their default values are the follows. </p><ul><li><code>banner(true)</code>: show banner to help to visually identify the start of the estimation. </li><li><code>verbose(true)</code>: show interim and final results.</li><li><code>ineff_index(true)</code>: compute the Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1987) efficiency index.</li><li><code>marginal(true)</code>: calculate the marginal effect of the inefficiency determinants (if any) on the unconditional mean of inefficiency.</li></ul><p>Turning these options to <code>false</code> may be useful particularly in simulation settings.</p><h4 id="Step-4:-Estimation"><a class="docs-heading-anchor" href="#Step-4:-Estimation">Step 4: Estimation</a><a id="Step-4:-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Estimation" title="Permalink"></a></h4><p>Step 1 to 3 prepare the model, and now we are ready to estimate it. We use <code>sfmodel_fit()</code> to start the estimation, and it returns a dictionary containing estimation results and other information of the model. In the following example, we save the returned dictionary in <code>res</code>.</p><pre><code class="language-julia hljs">res = sfmodel_fit(useData(df))</code></pre><ul><li><code>useData(df)</code>: name of the DataFrame (see Step 1).</li></ul><h4 id="Step-5:-Results-and-Post-Estimation-Analysis"><a class="docs-heading-anchor" href="#Step-5:-Results-and-Post-Estimation-Analysis">Step 5: Results and Post Estimation Analysis</a><a id="Step-5:-Results-and-Post-Estimation-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Results-and-Post-Estimation-Analysis" title="Permalink"></a></h4><p>The main estimation results are shown in the terminal after it is done. Let&#39;s see what we have.</p><pre><code class="nohighlight hljs">*********************************
       Estimation Results:
*********************************
Model type: the normal and truncated-normal model of Battese and Coelli (1995, JoE)
Number of observations: 271
Number of total iterations: 114
Converged successfully: true
Log-likelihood value: -87.21356

┌──────────┬────────┬─────────┬──────────┬──────────┬────────┬─────────┬─────────┐
│          │   Var. │   Coef. │ Std.Err. │        z │  P&gt;|z| │ 95%CI_l │ 95%CI_u │
├──────────┼────────┼─────────┼──────────┼──────────┼────────┼─────────┼─────────┤
│ frontier │  Lland │  0.3030 │   0.0704 │   4.3024 │ 0.0000 │  0.1650 │  0.4410 │
│          │ PIland │  0.2479 │   0.1762 │   1.4069 │ 0.1607 │ -0.0975 │  0.5933 │
│          │ Llabor │  1.1265 │   0.0843 │  13.3658 │ 0.0000 │  0.9613 │  1.2917 │
│          │  Lbull │ -0.4038 │   0.0602 │  -6.7130 │ 0.0000 │ -0.5217 │ -0.2859 │
│          │  Lcost │  0.0142 │   0.0130 │   1.0915 │ 0.2761 │ -0.0113 │  0.0396 │
│          │     yr │  0.0146 │   0.0104 │   1.4028 │ 0.1619 │ -0.0058 │  0.0350 │
│          │  _cons │  1.6699 │   0.3612 │   4.6234 │ 0.0000 │  0.9620 │  2.3778 │
│        μ │    age │ -0.0045 │   0.0144 │  -0.3154 │ 0.7527 │ -0.0327 │  0.0236 │
│          │ school │  0.0304 │   0.0701 │   0.4336 │ 0.6650 │ -0.1070 │  0.1678 │
│          │     yr │ -0.2238 │   0.2263 │  -0.9889 │ 0.3237 │ -0.6674 │  0.2198 │
│          │  _cons │ -0.1747 │   1.4744 │  -0.1185 │ 0.9058 │ -3.0644 │  2.7150 │
│  log_σᵤ² │  _cons │ -0.4083 │   1.0082 │  -0.4050 │ 0.6858 │ -2.3842 │  1.5677 │
│  log_σᵥ² │  _cons │ -3.2328 │   0.2984 │ -10.8324 │ 0.0000 │ -3.8177 │ -2.6479 │
└──────────┴────────┴─────────┴──────────┴──────────┴────────┴─────────┴─────────┘

Convert the constant log-parameter to its original scale, e.g., σ² = exp(log_σ²):
┌─────┬────────┬──────────┐
│     │  Coef. │ Std.Err. │
├─────┼────────┼──────────┤
│ σᵤ² │ 0.6648 │   0.6702 │
│ σᵥ² │ 0.0394 │   0.0118 │
└─────┴────────┴──────────┘

***** Additional Information *********
* OLS (frontier-only) log-likelihood: -104.96993
* Skewness of OLS residuals: -0.70351
* The sample mean of the JLMS inefficiency index: 0.33006
* The sample mean of the BC efficiency index: 0.74921

* The sample mean of inefficiency determinants&#39; marginal effects on E(u): (age = -0.00061, school = 0.00407, yr = -0.02997)
* Marginal effects of the inefficiency determinants at the observational level are saved in the return. See the follows.

* Use `name.list` to see saved results (keys and values) where `name` is the return specified in `name = sfmodel_fit(..)`. Values may be retrieved using the keys. For instance:
   ** `name.loglikelihood`: the log-likelihood value of the model;
   ** `name.jlms`: Jondrow et al. (1982) inefficiency index;
   ** `name.bc`: Battese and Coelli (1988) efficiency index;
   ** `name.marginal`: a DataFrame with variables&#39; (if any) marginal effects on E(u).
* Use `keys(name)` to see available keys.
**************************************</code></pre><p>As reminded in the printout, many of the model information are saved in the dictionary which can be called later for further investigation. Let&#39;s see the list of available keys first.</p><pre><code class="language-julia hljs">julia&gt; keys(res)
(:converged, :iter_limit_reached, :_______________, :n_observations, :loglikelihood, :table, :coeff, :std_err, :var_cov_mat, :jlms, :bc, :OLS_loglikelihood, :OLS_resid_skew, :marginal, :marginal_mean, :_____________, :model, :depvar, :frontier, :μ, :σₐ², :σᵤ², :σᵥ², :log_σₐ², :log_σᵤ², :log_σᵥ², :type, :dist, :coeff_frontier, :coeff_μ, :coeff_log_σᵤ², :coeff_log_σᵥ², :________________, :Hessian, :gradient_norm, :actual_iterations, :______________, :warmstart_solver, :warmstart_ini, :warmstart_maxIT, :main_solver, :main_ini, :main_maxIT, :tolerance, :eqpo, :redflag, :list)</code></pre><p>Among the keywords is the term <code>:coeff</code>, which is the keyword of the saved coefficient vector. We may retrieve the coefficient vector and save it in the name <code>b0</code> possibly for later use.</p><pre><code class="language-julia hljs">julia&gt; b0 = res.coeff
13-element Vector{Float64}:
  0.3029823393273174
  0.24794010653151866
  1.1265299143721006
 -0.4038266728402889
  0.014152608439534585
  0.014589911311642377
  1.6699115039893075
 -0.004532647263411585
  0.03039490853353706
 -0.22379268672696456
 -0.17467371095755305
 -0.40828210156522676
 -3.2327957145786477</code></pre><p>The estimation table shown above with the coefficients, standard errors, etc., may also be retrieved using the keyword <code>:table</code>, though it may not be formatted as pretty.</p><h4 id="Inefficiency-and-Efficiency-Index"><a class="docs-heading-anchor" href="#Inefficiency-and-Efficiency-Index">Inefficiency and Efficiency Index</a><a id="Inefficiency-and-Efficiency-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Inefficiency-and-Efficiency-Index" title="Permalink"></a></h4><p>The Jondrow et al. (1982) inefficiency index (<span>$E(u|\widehat{v_i-u_i})$</span>) and the Battese and Coelli (1987) efficiency index (<span>$E(\exp(-u)|\widehat{v_i-u_i})$</span>) may also be retrieved using the keywords <code>:jlms</code> and <code>:bc</code>. Here we show them in a <span>$N\times 2$</span> matrix.</p><pre><code class="language-julia hljs">julia&gt; [res.jlms res.bc]
271×2 Matrix{Float64}:
 0.536473   0.595487
 0.47957    0.630042
 0.0924123  0.914553
 0.239773   0.795486
 0.114407   0.89573
 ⋮
 0.410421   0.674444
 0.859055   0.431521
 0.119179   0.891702
 0.18474    0.838167
 0.169893   0.850018</code></pre><h4 id="Marginal-Effects"><a class="docs-heading-anchor" href="#Marginal-Effects">Marginal Effects</a><a id="Marginal-Effects-1"></a><a class="docs-heading-anchor-permalink" href="#Marginal-Effects" title="Permalink"></a></h4><p>Let&#39;s also show the marginal effects of the inefficient determinants at the observational level, which are saved as a DataFrame object.</p><pre><code class="language-julia hljs">julia&gt; res.marginal
271×3 DataFrame
│ Row │ marg_age     │ marg_school │ marg_yr    │
│     │ Float64      │ Float64     │ Float64    │
├─────┼──────────────┼─────────────┼────────────┤
│ 1   │ -0.000482249 │ 0.00323385  │ -0.0238103 │
│ 2   │ -0.000419427 │ 0.00281258  │ -0.0207086 │
│ 3   │ -0.000366921 │ 0.00246049  │ -0.0181162 │
│ 4   │ -0.000322813 │ 0.00216471  │ -0.0159384 │
│ 5   │ -0.000285561 │ 0.00191491  │ -0.0140992 │
⋮
│ 266 │ -0.000482007 │ 0.00323223  │ -0.0237984 │
│ 267 │ -0.000419226 │ 0.00281123  │ -0.0206987 │
│ 268 │ -0.00119146  │ 0.00798967  │ -0.0588266 │
│ 269 │ -0.00100688  │ 0.00675194  │ -0.0497134 │
│ 270 │ -0.000853674 │ 0.00572455  │ -0.0421489 │
│ 271 │ -0.000727005 │ 0.00487513  │ -0.0358948 │</code></pre><h4 id="Hypothesis-Testing"><a class="docs-heading-anchor" href="#Hypothesis-Testing">Hypothesis Testing</a><a id="Hypothesis-Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Hypothesis-Testing" title="Permalink"></a></h4><p>We may conduct a likelihood ration (LR) test to see if the frontier specification is supported by the data. The null hypothesis is that the inefficiency term <span>$u_i$</span> is not warranted and the fit of the model is no better than the OLS.</p><p>First, we calculate the test statistics using the log-likelihood values of the OLS model and the current model.</p><pre><code class="language-julia hljs">julia&gt; -2*(res.OLS_loglikelihood - res.loglikelihood)
35.51273933147917</code></pre><p>Because the test amounts to testing <span>$u_i =0$</span> which is on the boundary of the parameter&#39;s support, the appropriate distribution for the test statistic is the mixed <span>$\chi^2$</span> distribution. Critical values may be retrieved using <code>sfmodel_MixTable(dof)</code> where <code>dof</code> is the degree of freedom of the test. In this example, <code>dof=5</code> because there are five parameters involved in <span>$u_i$</span>.</p><pre><code class="language-julia hljs">julia&gt; sfmodel_MixTable(5)

  * Significance levels and critical values of the mixed χ² distribution
┌─────┬───────┬────────┬────────┬────────┐
│ dof │  0.10 │   0.05 │  0.025 │   0.01 │
├─────┼───────┼────────┼────────┼────────┤
│ 5.0 │ 8.574 │ 10.371 │ 12.103 │ 14.325 │
└─────┴───────┴────────┴────────┴────────┘

source: Table 1, Kodde and Palm (1986, Econometrica).</code></pre><p>Since the test statistic <span>$35.513$</span> is much larger than the critical value at the <span>$1\%$</span> level (which is <span>$14.325$</span>), the result overwhelmingly rejects the null hypothesis of an OLS model.</p><h4 id="Others"><a class="docs-heading-anchor" href="#Others">Others</a><a id="Others-1"></a><a class="docs-heading-anchor-permalink" href="#Others" title="Permalink"></a></h4><p><strong>SFrontiers</strong> provides the function <code>sfmodel_predict()</code> to obtain predicted values of the equations after the model is estimated. The following returns the predicted value of the <code>frontier</code> equation, i.e., <span>$\mathbf{x} \hat{\beta}$</span>.</p><pre><code class="language-julia hljs">julia&gt; xb = sfmodel_predict(@eq(frontier), df)
271-element Vector{Float64}:
 5.837738490387098
 5.467350523453003
 5.145107451544124
 5.494031744452952
 6.062700939460845
 6.097179092569791
 ⋮
 4.861054485639938
 6.393104647266437
 8.207717614833687
 7.894552876042939
 8.537385909249965
 6.373480344886016</code></pre><p><code>df</code> in the function is the name of the DataFrame which we had used to estimate the model.</p><p>We may also use it to predict values of <span>$\sigma_u^2$</span> for each observation, though in the current example it is trivial since <span>$\sigma_u^2$</span> is a constant.</p><pre><code class="language-julia hljs">julia&gt; sfmodel_predict(@eq( σᵤ² ), df)
271-element Vector{Float64}:
 0.6647913136972949
 0.6647913136972949
 0.6647913136972949
 ⋮
 0.6647913136972949
 0.6647913136972949
 0.6647913136972949</code></pre><h2 id="Normal-Truncated-Normal-Model-with-the-Scaling-Property"><a class="docs-heading-anchor" href="#Normal-Truncated-Normal-Model-with-the-Scaling-Property">Normal Truncated-Normal Model with the Scaling Property</a><a id="Normal-Truncated-Normal-Model-with-the-Scaling-Property-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-Truncated-Normal-Model-with-the-Scaling-Property" title="Permalink"></a></h2><h2 id="Normal-Half-Normal-Model"><a class="docs-heading-anchor" href="#Normal-Half-Normal-Model">Normal Half-Normal Model</a><a id="Normal-Half-Normal-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-Half-Normal-Model" title="Permalink"></a></h2><h2 id="Normal-Exponential-Model"><a class="docs-heading-anchor" href="#Normal-Exponential-Model">Normal Exponential Model</a><a id="Normal-Exponential-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-Exponential-Model" title="Permalink"></a></h2></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Saturday 28 August 2021 23:39">Saturday 28 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
